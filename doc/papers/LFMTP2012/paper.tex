\documentclass[9pt]{sigplanconf}

\usepackage{ntheorem}
\usepackage{amsmath}
\usepackage{amssymb}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\usepackage{macros}
\usepackage{mathpartir}
\usepackage{url}

\begin{document}

\conferenceinfo{LFMTP '12}{September 9, 2012 -- Copenhagen, Denmark}
\copyrightyear{2012}
\copyrightdata{[to be supplied]}

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Incremental tactics}
%\subtitle{Subtitle Text, if any}

\authorinfo{Matthias Puech}
           {Department of Comp. Sci., Univ. of Bologna,\\
             PPS, Team $\pi r^2$ (Univ. Paris Diderot, CNRS, INRIA)}
           {puech@cs.unibo.it}

\authorinfo{Yann R\'egis-Gianas}
           {PPS, Team $\pi r^2$ (Univ. Paris Diderot, CNRS, INRIA)}
           {yrg@pps.jussieu.fr}

\maketitle

%% Here is a problem
\begin{abstract}
  %% 4 sentences:
  %% State the problem
  %% Say why it’s an interesting problem
  %% Say what your solution achieves
  %% Say what follows from your solution
\end{abstract}

\category{D.3.3}{Language Constructs and Features}{Data types and
  structures} \category{F.3.1}{Logics and Meanings of
  Programs}{Specifying and Verifying and Reasoning about
  Programs --- Logics of programs}

\terms
Theory, Languages

\keywords
incrementality, type checking, logical framework, version control

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Introduction}
%% It’s an interesting problem (1 page)

As programming languages develop more static analysis like rich type
systems, programs get safer as bugs are caught earlier.

%% Describe the problem (Use an example)
%% State your contributions (Bulleted list of contributions)

\section{Background}
%% It’s an unsolved problem (1 page)

\section{Here is my idea}
%% Here is my idea (2 pages)

\subsection{The \LF\ representation language}

The emission of certificates by untrusted applications first raises
the question of the \emph{data structure} to use for these
certificates. The requirements are:
\begin{itemize}
\item conciseness of the certificates, since they are usually stored
  or transfered remotely; in particular,
\item a well-understood, short and independent verification algorithm;
  this is known as the \emph{de Bruijn principle}.
\item universality with respect to the particular problem: having a
  certificate language for each domain of application would just shift
  the problem of trust; having one universally accepted certificate
  language that can be tailored to many problems puts a much stronger
  trust on the unique verifier.
\end{itemize}

The Edimburgh Logical Framework \cite{harper1993framework}, or \LF\
for short, is a well-accepted solution to this question. It is a typed
lambda-calculus and can be viewed as a language for
\emph{representing} terms, derivations and statements of $\Pi_0^1$
meta-theorems (but not their proofs) in a given inference system
supporting hypothetical judgements \cite{pfenning2001logical}. For
these, it provides built-in support for encoding languages with
binders or hypothesis (a feature called $\lambda$-tree syntax or HOAS
\cite{pfenning1988higher}). The user gives a \emph{signature} defining
abstract syntax and inference rules of his \emph{object language}, and
gets an algorithm to verify terms and derivations expressed in the
\LF\ syntax.

This framework has been used to issue certificates for a number of
practical applications like proof-carrying code
\cite{necula1997proof}, authentication framework \cite{appel1999proof}
\ldots %TODO ATP

In all these applications, the user feeds the generation program with
a query (the program to compile to machine-code, the access query, the
statement of a theorem \ldots) and gets in return a result (machine
code, yes/no\ldots) together with a certificate that the result
verifies the wanted property (semantics preservation, justification
for granting access, proof of the theorem\ldots). A potential client
can then verify independently that this result is adequate given the
query: it suffices to batch-verify the certificate.

\subsection{Proof-carrying static analysis}

\subsection{Storing computation results}
\subsection{Naming intermediate results}

\section{Examples}



\section{The calculus}
%% My idea works (details, data) (5 pages)

\subsection{Core calculus}

The core calculus defines the \emph{values} we want to
manipulate. These contain constants, and --- contrarily to \eg\
\sysname{ML} values --- binders and variables enabling $\lambda$-tree
syntax. Thus, they embed a superficial notion of computation:
hereditary substitution. This calculus is an extension of \emph{spine
  canonical \LF} \cite{pfenning2007term} enriched with metavariables
which are references to open terms as in
\cite{nanevski2008contextual}. We present its typing algorithm
relatively to a signature. It features an explicit caching mechanism
using metavariables.

\paragraph{Syntax}

In this variant, only $\eta$-long $\beta$-normal forms have an
existence: canonicity for $\beta$-reduction is enforced in the syntax
and canonicity for $\eta$-expansion will be enforced by typing,
following \cite{hl07mechanizing}. Besides, application of a
\emph{head} (\ie\ a constant or variable) is $n$-ary (\ie\ to a
\emph{spine} of objects) as opposed to the more standard binary
application: this eases the definition substitution and
$\eta$-expansion, and corresponds to a focused sequent calculus known
as \sysname{LJT} \cite{herbelin1995λ}.

\begin{align*}
  K &\gequal
  \prd x A K \gor
  \type &
  \text{Kind}\\
  A &\gequal
  \prd x A A \gor
  \app {\cst a} S &
  \text{Type family} \\
  M &\gequal
  \lam x M \gor
  F \gor
  \smeta X \sigma &
  \text{Object} \\
  F &\gequal \app H S &
  \text{Application} \\
  H &\gequal
  \var x \gor
  \cst c &
  \text{Head}\\
  S &\gequal
  \spinenil \gor
  \spinecons M S &
  \text{Spine}\\
  \sigma &\gequal
  \msubstnil \gor
  \msubstcons \sigma x M &
  \text{Parallel substitution} \\
  \Gamma &\gequal
  \envnil \gor
  \envcons \Gamma x A &
  \text{Environment}
\end{align*}

As is customary, we adopt the Barendregt convention for naming bound
variables, write $A\to A'$ for $\prd x A A'$ when $\var x\notin \FV{A'}$,
$\meta X$ for $\smeta X \msubstnil$, and adopt indifferently list, map
or set notations for $\sigma$ and $\Gamma$. The identity substitution
$\msubstid{\Gamma}$ is a notation for $\{\msubst x {\var x}\ |\ \var x
\in\dom\Gamma\}$.

Metavariables $\smeta X \sigma$ stand for open objects with free
variables in $\dom{\sigma}$; they are defined in a repository (see
below). We write $\FMV{M}$ for the set of metavariables in $M$ and
speak of a \emph{metaclosed} object $M$ if $\FMV{M} = \emptyset$.

\paragraph{Substitution}

We overload \emph{substitution} as a partial operation on objects, given
a parallel substitution $\sigma$. Since the syntax of object is not
stable by (textual) substitution, it is defined \emph{hereditarily}: it
is mutually recursive with a \emph{cut} function $\gcut M S$ which can
in turn trigger a chain of substitutions, leading to a canonical objects
or an error.
\begin{align*}
  \gsubst {(\lam x M)} \sigma &= \lam x {\gsubst M \sigma} &
  \text{if $\var x\notin \dom{\sigma}$}
  \\
  \gsubst {(\app {\cst c} S)} \sigma &= \app {\cst c} {(\gsubst S
    \sigma)}
  \\
  \gsubst {(\app {\var x} S)} \sigma &=
  \app {\var x} {\gsubst S \sigma} &
  \text{if $\var x\notin \dom{\sigma}$}
  \\
  \gsubst {(\app {\var x} S)} \sigma &=
  \gcut M {\gsubst S \sigma} &
  \text{if $\sigma(\var x) = M$}
  \\
  \gsubst {\smeta X {\sigma}} {\sigma'} &=
  \smeta X {\gcomp\sigma{\sigma'}}
  \\
  \gsubst\spinenil\sigma &=
  \spinenil \\
  \gsubst{\spinecons M S}\sigma &=
  \spinecons{\gsubst M\sigma}{\gsubst S\sigma}
  \\
  \gcut {\lam x M} {\spinecons N S} &=
  \gcut {\gsubst M {\msubst x N}} S
  \\
  % TODO cas meta/S ????
  % \gcut {\smeta X\sigma} S &=
  % \smeta X{\gcomp\sigma\sigma'}
  % \\
  \gcut {\app H S} \spinenil &=
  \app H S
  \\
  \gcut {\smeta X\sigma} \spinenil &= \smeta X\sigma
  \\
  \gcomp \sigma \msubstnil &=
  \sigma
  \\
  \gcomp \sigma {(\msubstcons{\sigma'} x M)} &=
  \gcomp {\gsubst\sigma {\msubst x M}} \sigma'
  \\
  \gsubst {(\msubstcons{\sigma'} x M)} \sigma &=
  \msubstcons{\gsubst{\sigma'}\sigma} x {\gsubst M \sigma}
  \\
  \gsubst {\msubstnil}{\sigma} &= \msubstnil
\end{align*}

We extend this operation trivially on families $\gsubst A \sigma$ and
kinds $\gsubst K \sigma$. We also allow to abusively write
non-canonical applications $\app M S$ as a shorthand for $\gcut M S$
if they are defined.

Note that this notion of substitution differs from hereditary
substitution found in \eg\ \cite{hl07mechanizing} as it presupposes
$\eta$-long normal forms: a non-empty spine cut against to another
non-empty spine $\gcut {\app H S} {S'}$ blocks the substitution
instead of reducing to $\app H {(\gconcat S S')}$ (an implicit
$\eta$-expansion). For example, the reduction $\gcut {\lam x \app
  {\var x}{\var x}} {\lam x \app {\var x}{\var x}}$ gets stuck because
the second $\var x$ in the left part is substituted by a function yet
is not itself a function.

% TODO pourquoi cette def?
% TODO terminaison??
% TODO stabilité de la eta?
% TODO comparer avec la def usuelle

\paragraph{Typing algorithm}

Typing an object while storing intermediate derivations requires
threading and maintaining a data structure of named partial
derivations (\emph{slices}) throughout the typing process. We present
a bidirectional typing algorithm updating an input repository.

A \emph{signature} declares object and type constants to be used in
objects. To each object constant we assign an annotation $L$ setting
the slicing behaviour of the constant during type-checking: either
sliceable $\annsliceable$ (each application of this constant will be
cached and given a name), non-sliceable $\annnonsliceable$ (we don't
create a name for applications of this constant), or defined
$\anndefined{T}$ (see \ref{sec:computational-calculus}).
\begin{align*}
  L &\gequal
  \annsliceable \gor
  \annnonsliceable \gor
  \anndefined{T}
  \\
  \Sigma &\gequal
  \gnil \gor
  \gcons \Sigma {\cst c :^L A} \gor
  \gcons \Sigma {\cst a : K}
  &\text{Signature}
\end{align*}
We write $\Sigma(\cst c) = A; L$ for $(\cst c :^L A) \in \Sigma$
suggesting the implementation of signatures as maps.

Our algorithm types exactly the well-typed objects of the usual
\LF, except that we thread a repository $\mr$ and store in it
all well-typed applicative subterms $F$ along with their classifier
$A$ and the environment in which they are well-typed.

% TODO parler de la redondance en LF normal

A \emph{repository} $\mr$ is a finite map from metavariable to
judgements of object well-typing, along with a distinguished
metavariable, the \emph{head}:
$$ \mr\;:\;(\meta X \mapsto (\Gamma\vdash\tp M A)), \smeta X \sigma $$
We maintain the invariant that a repository $\mr$ is
\emph{acyclic}, that is for all $\meta X$ in $\mr$, the fixpoint
of $\FMV{\meta X}$ does not contain $\meta X$. With $\mr =
(\Delta, X[\sigma])$, we write $\hat {\mr}$ for $X[\sigma]$,
abusively $\mr$ for $\Delta$ and $\mr (\smeta X \sigma)$ for
$\gsubst M\sigma$ if $\Delta(\meta X) = (\Gamma\vdash M : A)$.

We refer to cached subterms by metavariables. We force instantiation
of all variables in their environment by attaching a substitution to
them ($\smeta X \sigma$).

When checking large objects, the environment can grow fast. As an
optimization to reduce the size of the stored environments and
substitutions in slices $M$, we strengthen environments to their
minimum size (the free variables of $M$): We define the operation of
\emph{strengthening} from an environment $\Gamma$ and an object $M$
well-typed in $\Gamma$ to the minimal environment in which $M$ can
actually be typed, \ie\ containing only its free variables:
$$
\stren{\Gamma,M} = \{x : A\ |\ x\in \FV{M} \wedge \Gamma(x)=A\}
$$
% TODO lemme qui dit que c'est correct wrt variables libres des A et
% du type

The algorithm is presented in Fig. \ref{fig:obj-typing} as a
syntax-directed inference system. All judgements are of the form $\gjo
U V W$ where $U$ and $V$ are inputs, $V$ is the induction hypothesis
and $W$ the output. They are parameterized by a constant and implicit
signature $\Sigma$, and all premisses are ordered in the algorithmical
order of computation.

\begin{figure*}

  \fbox{$\jm\mr\Gamma M A \mmr {M'}$}
  \qquad
  Object typing

  \begin{mathpar}
    % Lambda
    \infer{
      \jm\mr{\envcons\Gamma x A} M {A'} \mmr {M'}
    }{
      \jm\mr\Gamma {\lam x M} {\prd x A {A'}} \mmr {\lam x M'}
    }

    % App
    \infer{
      \jf\mr\Gamma F \mmr {M'} {A'}
       \and
      \jea\mmr\Gamma A {A'}
    }{
      \jm\mr\Gamma F A \mmr {M'}
    }

    % Meta
    \infer{
      \mr(\meta X) = (\Gamma'\vdash M:A')
      \and
      \js\mr\Gamma \sigma {\Gamma'} \mmr {\sigma'}
      \and
      \jea\mmr\Gamma A {\gsubst {A'} {\sigma'}}
    }{
      \jm\mr\Gamma {\smeta X \sigma} A \mmr {M'}
    }
  \end{mathpar}

  \fbox{$\js\mr\Gamma\sigma{\Gamma'}\mmr{\sigma'}$}
  \qquad
  {Substitution typing}

  \begin{mathpar}

    % Cons
    \infer{
      \js\mr\Gamma\sigma{\Gamma'}\mmr{\sigma'}
      \and
      \jm\mmr\Gamma M {\gsubst A {\sigma'}} \mmmr {M'}
    }{
      \js\mr\Gamma{(\msubstcons \sigma x M)} {(\envcons {\Gamma'} x {A'})}
      \mmmr {(\msubstcons {\sigma'} x {M'})}
    }

    % Nil
    \infer{ }{
      \js\mr\Gamma\msubstnil\envnil\mr\envnil
    }

  \end{mathpar}


  \fbox{$\jf\mr\Gamma F \mmr M A$}
  \qquad
  {Application typing}

  \begin{mathpar}

    % Non-sliceable
    \infer{
      \jh\mr\Gamma H A \annnonsliceable
      \and
      \jl\mr\Gamma A S \mmr {S'} {A'}
    }{
      \jf\mr\Gamma {\app H S} \mmr {\app H {S'}} {A'}
    }

    % Sliceable
    \infer{
      \jh\mr\Gamma H A \annsliceable
      \and
      \jl\mr\Gamma A S \mmr {S'} {A'}
      \and
      \jp\mmr\Gamma {\app H S} A \mmmr
    }{
      \jf\mr\Gamma {\app H S} \mmmr {\hat\mmmr} {A'}
    }

  \end{mathpar}

  \fbox{$\jh\mr\Gamma H A L$}
  \qquad
  {Head typing}

  \begin{mathpar}
    % constant
    \infer{
      \Sigma(\cst c) = A; L
    }{
      \jh\mr\Gamma {\cst c} A L
    }

    % variable
    \infer{
      \Gamma(\var x) = A
    }{
      \jh\mr\Gamma {\var x} A \annnonsliceable
    }
  \end{mathpar}

  \fbox{$\jl\mr\Gamma A S \mmr{S'}{A'}$}
  \qquad
  {Spine typing}

  \fbox{$\jp\mr\Gamma M A \mmr$}
  \qquad
  {Push}

  \begin{mathpar}
    \infer{
      \stren{\Gamma, M}=\Gamma'
      \and
      \text{$\meta X$ fresh in $\Delta$}
    }{
      \jp{(\Delta; \smeta Z {\sigma})}\Gamma M A {(\mapadd\Delta{\meta
          X}{(\Gamma'\vdash M:A)}; \smeta X {\msubstid\Gamma})}
    }
  \end{mathpar}

  \caption{Typing algorithm for objects}
  \label{fig:obj-typing}
\end{figure*}

The main judgement is application typing $\jf\mr\Gamma F \mmr M A$,
which means that in repository $\mr$ and environment $\Gamma$, the
applicative term $F$ is well-typed of type $A$, and the slicing of $F$
produces a new repository $\mmr$. The object $M$ is the
\emph{residual} of this operation: only certain kind of applications
are sliced, and it is possible that the ``tip'' of application $F$ is
not sliced (because it is declared as non-sliceable). In that case,
$M$ is this tip; if $F$ is directly sliceable, then $M$ is the
metavariable referring to it.

Definitional equality judgement between two families $\jea\mr\Gamma A
{A'}$ is used by these typing rules. This equivalence is usually
defined to be just $\alpha$-equivalence since objects are in
$\beta\eta$-canonical form. Here, objects can contain metavariables
defined in $\mr$, so we shall thread it. Moreover, we will see in the
next section how defined constants compute and thus influence
definitional equality. Definitional equality is defined later in
\ref{fig:def-eq}.

Signatures themselves need to be checked. We present the checking
algorithm in Fig. \ref{fig:sign-typing}.

\begin{figure*}
  \fbox{$\jsig\mr\Sigma\mmr{\Sigma'}$}
  \qquad
  {Signature}

  \begin{mathpar}
    \infer{ }{
      \jsig\mr\gnil\mr\gnil
    }

    \infer{
      \jsig\mr\Sigma\mmr{\Sigma'}
      \and
      \jfam\mmr\gnil {\!_{\Sigma'} A}\mmmr {A'}
    }{
      \jsig\mr{\gcons\Sigma{{\cst c :^L A}}}\mmmr{\gcons{\Sigma'}{{\cst c :^L A'}}}
    }

    \infer{
      \jsig\mmr\Sigma\mmmr{\Sigma'}
      \and
      \jkind\mr\gnil {\!_{\Sigma'} K}\mmr {K'}
    }{
      \jsig\mr{\gcons\Sigma{{\cst a : K}}}\mmmr{\gcons{\Sigma'}{{\cst a : K'}}}
    }
  \end{mathpar}

  \fbox{$\jfam\mr\Gamma A \mmr {A'}$}
  \qquad
  {Family}

  \begin{mathpar}

    \infer{
      \jfam\mr\Gamma {A_1} \mmr {A_1'}
      \and
      \jfam\mmr{\gcons\Gamma{\tp {\var x} {A_1'}}} {A_2} \mmmr {A_2'}
    }{
      \jfam\mr\Gamma {\prd x {A_1} {A_2}} \mmmr {\prd x {A_1'} {A_2'}}
    }

    \infer{
      \Sigma(a) = K
      % TODO
    }{
      \jfam\mr\Gamma {\app{\cst a} S} \mmr {\app{\cst a} {S'}}
    }

  \end{mathpar}

  \fbox{$\jkind\mr\Gamma K \mmr {K'}$}
  \qquad
  {Kind}

  \begin{mathpar}
    
  \end{mathpar}

  \caption{Typing algorithm for signatures}
  \label{fig:sign-typing}
\end{figure*}

\paragraph{Example}

Let us work out an example.
% TODO example

\paragraph{Checkout}

We define the partial \emph{checkout} operation $\checkout{\mr}$
(resp. $\checkoutr{M}$, $\checkoutr{S}$) from a repository
(resp. object, spine) to a metaclosed object as unfolding the
definitions of all metavariables recursively:
\begin{align*}
  \checkout{\mr} &= \checkoutr{\hat{\mr}} \\
  \checkoutr{\smeta X \sigma} &= \checkoutr{\mr(\smeta X\sigma)}\\
  \checkoutr{\lam x M} &= \lam x \checkoutr{M} \\
  \checkoutr{\app H S} &= \app H {(\checkoutr{S})} \\
  \checkoutr{\spinecons M S} &= \spinecons {\checkoutr M} {\checkoutr S} \\
  \checkoutr{\spinenil} &= \spinenil
\end{align*}

A repository is said to be \emph{well-formed} if $\checkout {\mr}$
is defined.

\begin{theorem}
  If \/ $\jm\mr\Gamma M A \mmr {M'}$ then \/ $\jem\mmr\Gamma M {M'} A$
\end{theorem}

\begin{theorem}
  If \/ $\jm\mr\Gamma M A \mmr {M'}$ then \/ $\jlfm\Gamma {(\checkoutr
    M)} (\checkoutr A)$
\end{theorem}

\subsection{The computation calculus}
\label{sec:computational-calculus}

We now turn to the definition of our computation calculus. As we saw,
it is attached to special, \emph{defined} constants in the signature
and manipulates \LF\ objects. This language is un(i)typed, in that all
\LF\ objects have the same implicit type $\cst{obj}$. We have the
ability to construct objects out of other, and deconstruct them by
case analysis:
\begin{align*}
  T &\gequal
  \lam x T \gor
  U \\
  U &\gequal
  F \gor
  \matchin U \Gamma \casenobar {\app {H} {\vec x}} U\ |\ \ldots\
  \case {\app {H} {\vec x}} U
\end{align*}

\begin{figure*}
  \centering
  TODO
  \caption{Weak head-reduction}
  \label{fig:whr}
\end{figure*}

\begin{figure*}
  \centering
  TODO
  \caption{Definitional equality}
  \label{fig:def-eq}
\end{figure*}

\section{Implementation}

\section{Related work}
% 1-2 pages

\section*{Conclusion and future work}
% 0.5 pages

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{abbrvnat}
\bibliography{../../english.bib}


% \begin{thebibliography}{}
% \softraggedright
% \bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
% P. Q. Smith, and X. Y. Jones. ...reference text...
% \end{thebibliography}

\end{document}
