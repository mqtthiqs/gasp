\documentclass[9pt]{sigplanconf}

\usepackage{ntheorem}
\usepackage{amsmath}
\usepackage{amssymb}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\usepackage{macros}
\usepackage{mathpartir}
\usepackage{url}

\begin{document}

\conferenceinfo{LFMTP '12}{September 9, 2012 -- Copenhagen, Denmark}
\copyrightyear{2012}
\copyrightdata{[to be supplied]}

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Incremental tactics}
%\subtitle{Subtitle Text, if any}

\authorinfo{Matthias Puech}
           {Department of Comp. Sci., Univ. of Bologna,\\
             PPS, Team $\pi r^2$ (Univ. Paris Diderot, CNRS, INRIA)}
           {puech@cs.unibo.it}

\authorinfo{Yann R\'egis-Gianas}
           {PPS, Team $\pi r^2$ (Univ. Paris Diderot, CNRS, INRIA)}
           {yrg@pps.jussieu.fr}

\maketitle

%% Here is a problem
\begin{abstract}
 %% 4 sentences:
 %% State the problem
 %% Say why it’s an interesting problem
 %% Say what your solution achieves
 %% Say what follows from your solution
\end{abstract}

\category{D.3.3}{Language Constructs and Features}{Data types and
  structures} \category{F.3.1}{Logics and Meanings of
  Programs}{Specifying and Verifying and Reasoning about
  Programs --- Logics of programs}

\terms
Theory, Languages

\keywords
incrementality, type checking, logical framework, version control

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Introduction}
%% It’s an interesting problem (1 page)

%% Describe the problem (Use an example)
%% State your contributions (Bulleted list of contributions)

\section{Background}
%% It’s an unsolved problem (1 page)

\section{Here is my idea}
%% Here is my idea (2 pages)

\subsection{The \LF\ representation language}

The emission of certificates by untrusted applications first raises
the question of the \emph{data structure} to use for these
certificates. The requirements are:
\begin{itemize}
\item conciseness of the certificates, since they are usually stored
  or transfered remotely; in particular,
\item a well-understood, short and independent verification algorithm;
  this is known as the \emph{de Bruijn principle}.
\item universality with respect to the particular problem: having a
  certificate language for each domain of application would just shift
  the problem of trust; having one universally accepted certificate
  language that can be tailored to many problems puts a much stronger
  trust on the unique verifier.
\end{itemize}

The Edimburgh Logical Framework \cite{harper1993framework}, or \LF\
for short, is a well-accepted solution to this question. It is a typed
lambda-calculus and can be viewed as a language for
\emph{representing} terms, derivations and statements of $\Pi_0^1$
meta-theorems (but not their proofs) in a given inference system
supporting hypothetical judgements \cite{pfenning2001logical}. For
these, it provides built-in support for encoding languages with
binders or hypothesis (a feature called $\lambda$-tree syntax or HOAS
\cite{pfenning1988higher}). The user gives a \emph{signature} defining
abstract syntax and inference rules of his \emph{object language}, and
gets an algorithm to verify terms and derivations expressed in the
\LF\ syntax.

This framework has been used to issue certificates for a number of
practical applications like proof-carrying code
\cite{necula1997proof}, authentication framework \cite{appel1999proof}
\ldots %TODO ATP

In all these applications, the user feeds the generation program with
a query (the program to compile to machine-code, the access query, the
statement of a theorem \ldots) and gets in return a result (machine
code, yes/no\ldots) together with a certificate that the result
verifies the wanted property (semantics preservation, justification
for granting access, proof of the theorem\ldots). A potential client
can then verify independently that this result is adequate given the
query: it suffices to batch-verify the certificate.

\subsection{Proof-carrying static analysis}

\subsection{Storing computation results}
\subsection{Naming intermediate results}

\section{Examples}



\section{The calculus}
%% My idea works (details, data) (5 pages)

\subsection{Value calculus}

The value calculus defines the \emph{values} we want to
manipulate. These contain constants, and --- contrarily to \eg\
\sysname{ML} values --- binders and variables enabling $\lambda$-tree
syntax. Thus, they embed a superficial notion of computation:
hereditary substitution. This calculus is an extension of \emph{spine
  canonical \LF} \cite{pfenning2007term} enriched with metavariables
which are references to open terms as in
\cite{nanevski2008contextual}. We present its typing algorithm
relatively to a signature. It features an explicit caching mechanism
using metavariables.

\paragraph{Syntax}

In this variant, only $\eta$-long $\beta$-normal forms have an
existence: canonicity for $\beta$-reduction is enforced in the syntax
and canonicity for $\eta$-expansion will be enforced by typing,
following \cite{hl07mechanizing}. Besides, application of a
\emph{head} (\ie\ a constant or variable) is $n$-ary (\ie\ to a
\emph{spine} of objects) as opposed to the more standard binary
application: this eases the definition substitution and
$\eta$-expansion, and corresponds to a focused sequent calculus known
as \sysname{LJT} \cite{herbelin1995λ}.

\begin{align*}
  K &\gequal
  \prd x A K \gor
  \type &
  \text{Kind}\\
  A &\gequal
  \prd x A A \gor
  \app {\cst a} S &
  \text{Type family} \\
  M &\gequal
  \lam x M \gor
  F &
  \text{Object} \\
  F &\gequal \app H S
  \gor
  \smeta X \sigma &
  \text{Application} \\
  H &\gequal
  \var x \gor
  \cst c &
  \text{Head}\\
  S &\gequal
  \spinenil \gor
  \spinecons M S &
  \text{Spine}\\
  \sigma &\gequal
  \msubstnil \gor
  \msubstcons \sigma x M &
  \text{Parallel substitution} \\
  \Gamma &\gequal
  \envnil \gor
  \envcons \Gamma x A &
  \text{Environment}
\end{align*}

As is customary, we adopt the Barendregt convention for naming bound
variables, write $A\to A'$ for $\prd x A A'$ when $\var x\notin \FV{A'}$,
$\meta X$ for $\smeta X \msubstnil$, and adopt indifferently list, map
or set notations for $\sigma$ and $\Gamma$. The identity substitution
$\msubstid{\Gamma}$ is a notation for $\{\msubst x {\var x}\ |\ \var x
\in\dom\Gamma\}$.

% TODO com M check/F infer

Metavariables $\smeta X \sigma$ stand for open objects with free
variables in $\dom{\sigma}$; To each use of them is attached a
substitution $\sigma$ defining these free variables. They are defined
in a repository (see below). We write $\FMV{M}$ for the set of
metavariables in $M$ and speak of a \emph{metaclosed} object $M$ if
$\FMV{M} = \emptyset$.

\paragraph{Substitution}

We overload \emph{substitution} as a partial operation on objects, given
a parallel substitution $\sigma$. Since the syntax of object is not
stable by (textual) substitution, it is defined \emph{hereditarily}: it
is mutually recursive with a \emph{cut} function $\gcut M S$ which can
in turn trigger a chain of substitutions, leading to a canonical objects
or an error.
\begin{align*}
  \gsubst {(\lam x M)} \sigma &= \lam x {\gsubst M \sigma} &
  \text{if $\var x\notin \dom{\sigma}$}
  \\
  \gsubst {(\app {\cst c} S)} \sigma &= \app {\cst c} {(\gsubst S
    \sigma)}
  \\
  \gsubst {(\app {\var x} S)} \sigma &=
  \app {\var x} {\gsubst S \sigma} &
  \text{if $\var x\notin \dom{\sigma}$}
  \\
  \gsubst {(\app {\var x} S)} \sigma &=
  \gcut M {\gsubst S \sigma} &
  \text{if $\sigma(\var x) = M$}
  \\
  \gsubst {\smeta X {\sigma}} {\sigma'} &=
  \smeta X {\gcomp\sigma{\sigma'}}
  \\
  \gsubst\spinenil\sigma &=
  \spinenil \\
  \gsubst{\spinecons M S}\sigma &=
  \spinecons{\gsubst M\sigma}{\gsubst S\sigma}
  \\
  \gcut {\lam x M} {\spinecons N S} &=
  \gcut {\gsubst M {\msubst x N}} S
  \\
  % TODO cas meta/S ? rem: on en a pas besoin ds le proto.
  % \gcut {\smeta X\sigma} S &=
  % \smeta X{\gcomp\sigma\sigma'}
  % \\
  \gcut {\app H S} \spinenil &=
  \app H S
  \\
  \gcut {\smeta X\sigma} \spinenil &= \smeta X\sigma
  \\
  \gcomp \sigma \msubstnil &=
  \sigma
  \\
  \gcomp \sigma {(\msubstcons{\sigma'} x M)} &=
  \gcomp {\gsubst\sigma {\msubst x M}} \sigma'
  \\
  \gsubst {(\msubstcons{\sigma'} x M)} \sigma &=
  \msubstcons{\gsubst{\sigma'}\sigma} x {\gsubst M \sigma}
  \\
  \gsubst {\msubstnil}{\sigma} &= \msubstnil
\end{align*}

We extend this operation trivially on families $\gsubst A \sigma$ and
kinds $\gsubst K \sigma$. We also allow to abusively write
non-canonical application $\app M S$ as a shorthand for $\gcut M S$
if it is defined.

Note that this notion of substitution differs from hereditary
substitution found in \eg\ \cite{hl07mechanizing} as it presupposes
$\eta$-long normal forms: once a cut starts, there must be exactly as
many formal and actual arguments. A non-empty spine cut against
another non-empty spine $\gcut {\app H S} {S'}$ blocks the
substitution instead of reducing to $\app H {(\gconcat S S')}$ (an
implicit $\eta$-expansion); conversely, exhausting actual but not
formal arguments as in $\gcut{\lam x M}{\gnil}$ blocks the
substitution too. For example, the reduction $\gcut {\lam x \app {\var
    x}{\var x}} {\lam x \app {\var x}{\var x}}$ gets stuck because the
second $\var x$ in the left part is substituted by a function yet is
not itself a function.

% TODO pourquoi cette def?
% TODO terminaison?
% TODO stabilité de la eta?

\paragraph{Typing algorithm}

Typing an object while storing intermediate derivations requires
threading and maintaining a data structure of named partial
derivations (\emph{slices}) throughout the typing process. We present
a bidirectional typing algorithm updating an input repository.

A \emph{signature} declares object and type constants to be used in
objects. To each object constant we assign an annotation $L$ setting
the slicing behaviour of the constant during type-checking: either
sliceable $\annsliceable$ (each application of this constant will be
cached and given a name), non-sliceable $\annnonsliceable$ (we don't
create a name for applications of this constant), or defined
$\anndefined{T}$ (see \ref{sec:computational-calculus}).
\begin{align*}
  L &\gequal
  \annsliceable \gor
  \annnonsliceable \gor
  \anndefined{T}
  \\
  \Sigma &\gequal
  \gnil \gor
  \gcons \Sigma {\cst c :^L A} \gor
  \gcons \Sigma {\cst a : K}
  &\text{Signature}
\end{align*}
We write $\Sigma(\cst c) = A; L$ for $(\cst c :^L A) \in \Sigma$
suggesting the implementation of signatures as maps.

Our algorithm types exactly the well-typed objects of the usual
\LF, except that we thread a repository $\mr$ and store in it
all well-typed applicative subterms $F$ along with their classifier
$A$ and the environment in which they are well-typed.

% TODO parler de la redondance en LF normal

A \emph{repository} $\mr$ is a finite map from metavariable to
judgements of object well-typing, along with a distinguished
metavariable, the \emph{head}:
$$ \mr\;:\;(\meta X \mapsto (\Gamma\vdash\tp M A)), \smeta X \sigma $$
We maintain the invariant that a repository $\mr$ is
\emph{acyclic}, that is for all $\meta X$ in $\mr$, the fixpoint
of $\FMV{\meta X}$ does not contain $\meta X$. If $\mr =
(\Delta, X[\sigma])$, we write $\hat {\mr}$ for $X[\sigma]$,
abusively $\mr$ for $\Delta$ and $\mr (\smeta X \sigma)$ for
$\gsubst M\sigma$ if $\Delta(\meta X) = (\Gamma\vdash M : A)$.

We refer to cached subterms by metavariables. We force instantiation
of all variables in their environment by attaching a substitution to
them ($\smeta X \sigma$).

When checking large objects, the environment can grow fast. As an
optimization to reduce the size of the stored environments and
substitutions in slices $M$, we strengthen environments to their
minimum size (the free variables of $M$): We define the operation of
\emph{strengthening} from an environment $\Gamma$ and an object $M$
well-typed in $\Gamma$ to the minimal environment in which $M$ can
actually be typed, \ie\ containing only its free variables:
$$
\stren{\Gamma,M} = \{x : A\ |\ x\in \FV{M} \wedge \Gamma(x)=A\}
$$
% TODO lemme qui dit que c'est correct wrt variables libres des A et
% du type

The algorithm is presented in Fig. \ref{fig:obj-typing} as a
syntax-directed inference system. All judgements are of the form $\gjo
U V W$ where $U$ and $V$ are inputs, $V$ is the induction hypothesis
and $W$ the output. They are parameterized by a constant and implicit
signature $\Sigma$, and all premisses are ordered in the algorithmical
order of computation.

\begin{figure*}

  \fbox{$\jm\mr\Gamma M A \mmr {M'}$}
  \qquad
  Object

  \begin{mathpar}
    % Lambda
    \infer{
      \jm\mr{\envcons\Gamma x A} M {A'} \mmr {M'}
    }{
      \jm\mr\Gamma {\lam x M} {\prd x A {A'}} \mmr {\lam x M'}
    }

    % App
    \infer{
      \jf\mr\Gamma F \mmr {F'} {A'}
       \and
      \jea\mmr\Gamma {\app{\cst a} S} {A'}
    }{
      \jm\mr\Gamma F {\app{\cst a} S} \mmr {F'}
    }
    % TODO commenter type ground
  \end{mathpar}

  \fbox{$\js\mr\Gamma\sigma{\Gamma'}\mmr{\sigma'}$}
  \qquad
  {Substitution}

  \begin{mathpar}

    % Cons
    \infer{
      \js\mr\Gamma\sigma{\Gamma'}\mmr{\sigma'}
      \and
      \jm\mmr\Gamma M {\gsubst A {\sigma'}} \mmmr {M'}
    }{
      \js\mr\Gamma{(\msubstcons \sigma x M)} {(\envcons {\Gamma'} x {A'})}
      \mmmr {(\msubstcons {\sigma'} x {M'})}
    }

    % Nil
    \infer{ }{
      \js\mr\Gamma\msubstnil\envnil\mr\envnil
    }

  \end{mathpar}

  \fbox{$\jf\mr\Gamma F \mmr F A$}
  \qquad
  {Application}

  \begin{mathpar}

    % Non-sliceable
    \infer{
      \jh\mr\Gamma H A \annnonsliceable
      \and
      \jl\mr\Gamma A S \mmr {S'} {A'}
    }{
      \jf\mr\Gamma {\app H S} \mmr {\app H {S'}} {A'}
    }

    % Meta
    \infer{
      \mr(\meta X) = (\Gamma'\vdash M:A)
      \and
      \js\mr\Gamma \sigma {\Gamma'} \mmr {\sigma'}
    }{
      \jf\mr\Gamma {\smeta X \sigma} \mmr {\smeta X {\sigma'}} {\gsubst{A}\sigma'}
    }

    % Sliceable
    \infer{
      \jh\mr\Gamma H A \annsliceable
      \and
      \jl\mr\Gamma A S \mmr {S'} {A'}
      \and
      \stren{\Gamma, \app H {S'}}=\Gamma'
      \and
      \text{$\meta X$ fresh in $\mr$}
    }{
      \jf\mr\Gamma {\app H S} {\mapadd\mmr{\meta X}{(\Gamma'\vdash
          {\app H {S'}}:A)}} {\smeta X{\msubstid{\Gamma'}}} {A'}
    }

  \end{mathpar}

  \fbox{$\jh\mr\Gamma H A L$}
  \qquad
  {Head}

  \begin{mathpar}
    % constant
    \infer{
      \Sigma(\cst c) = A; L
    }{
      \jh\mr\Gamma {\cst c} A L
    }

    % variable
    \infer{
      \Gamma(\var x) = A
    }{
      \jh\mr\Gamma {\var x} A \annnonsliceable
    }
  \end{mathpar}

  \fbox{$\jl\mr\Gamma A S \mmr{S'}{A'}$}
  \qquad
  {Spine}

  \begin{mathpar}
    \infer{
      \jm\mr\Gamma M A \mmr {M'}
      \and
      \jl\mmr\Gamma {\gsubst{A'}{M'}} S \mmmr {S'} {A''}
    }{
      \jl\mr\Gamma {\prd x {A} {A'}} {\spinecons M S} \mmmr {\spinecons
      {M'}{S'}} {A''}
    }

    \infer{ }{
      \jl\mr\Gamma {\app{\cst a} S} \spinenil \mr \spinenil {{\app{\cst a} S}}
    }
  \end{mathpar}

  \caption{Typing algorithm for objects}
  \label{fig:obj-typing}
\end{figure*}

The main judgement is application typing $\jf\mr\Gamma F \mmr {F'} A$,
which means that in repository $\mr$ and environment $\Gamma$, the
applicative term $F$ is well-typed of type $A$, and the slicing of $F$
produces a new repository $\mmr$. The object $F'$ is the
\emph{residual} of this operation: only certain kind of applications
are sliced, and it is possible that the ``tip'' of application $F$ is
not sliced (because it is declared as non-sliceable). In that case,
$M$ is this tip; if $F$ is directly sliceable, then $M$ is the
metavariable referring to it.

These typing rules use definitional equality judgement between two
families $\jea\mr\Gamma A {A'}$. This equivalence is usually defined
to be just $\alpha$-equivalence since objects are in
$\beta\eta$-canonical form. Here, objects can contain metavariables
defined in $\mr$, so we shall thread it. Moreover, we will see in the
next section how defined constants compute and thus influence
definitional equality. Definitional equality is defined later in Fig.
\ref{fig:def-eq}.

Signatures themselves need to be checked. We present the checking
algorithm in Fig. \ref{fig:sign-typing}.

\begin{figure*}
  \fbox{$\jsig\mr\Sigma\mmr{\Sigma'}$}
  \qquad
  {Signature}

  \begin{mathpar}

    \infer{
      \jsig\mr\Sigma\mmr{\Sigma'}
      \and
      \jfam\mmr\gnil {\!_{\Sigma'} A}\mmmr {A'}
    }{
      \jsig\mr{\gcons\Sigma{{\cst c :^L A}}}\mmmr{\gcons{\Sigma'}{{\cst c :^L A'}}}
    }

    \infer{
      \jsig\mmr\Sigma\mmmr{\Sigma'}
      \and
      \jkind\mr\gnil {\!_{\Sigma'} K}\mmr {K'}
    }{
      \jsig\mr{\gcons\Sigma{{\cst a : K}}}\mmmr{\gcons{\Sigma'}{{\cst a : K'}}}
    }

    \infer{ }{
      \jsig\mr\gnil\mr\gnil
    }
  \end{mathpar}

  \fbox{$\jfam\mr\Gamma A \mmr {A'}$}
  \qquad
  {Family}

  \begin{mathpar}

    \infer{
      \jfam\mr\Gamma {A_1} \mmr {A_1'}
      \and
      \jfam\mmr{\gcons\Gamma{\tp {\var x} {A_1'}}} {A_2} \mmmr {A_2'}
    }{
      \jfam\mr\Gamma {\prd x {A_1} {A_2}} \mmmr {\prd x {A_1'} {A_2'}}
    }

    \infer{
      \Sigma(a) = K
      \and
      \jfl\mr\Gamma K S \mmr {S'}
    }{
      \jfam\mr\Gamma {\app{\cst a} S} \mmr {\app{\cst a} {S'}}
    }
  \end{mathpar}


  \fbox{$\jfl\mr\Gamma K S \mmr {S'}$}
  \qquad
  {Family spine}

  \begin{mathpar}
    \infer{
      \jm\mr\Gamma M A \mmr {M'}
      \and
      \jfl\mmr\Gamma {\gsubst{K}{M'}} S \mmmr {S'}
    }{
      \jfl\mr\Gamma {\prd x {A} {K}} {\spinecons M S} \mmmr {\spinecons
      {M'}{S'}}
    }

    \infer{ }{
      \jfl\mr\Gamma\type\spinenil\mr\spinenil
    }
  \end{mathpar}

  \fbox{$\jkind\mr\Gamma K \mmr {K'}$}
  \qquad
  {Kind}

  \begin{mathpar}
    \infer{
      \jfam\mr\Gamma A\mmr{A'}
      \and
      \jkind\mmr{\envcons\Gamma x A} K \mmmr {K'}
    }{
      \jkind\mr\Gamma{\prd x A K}\mmmr{\prd x {A'}{K'}}
    }

    \infer{ }{\jkind\mr\Gamma\type\mr\type}
  \end{mathpar}

  \caption{Typing algorithm for signatures}
  \label{fig:sign-typing}
\end{figure*}

\paragraph{Commit}
% TODO commit

\paragraph{Example}

Let us work out an example.
% TODO example

\paragraph{Checkout}

We define the partial \emph{checkout} operation $\checkout{\mr}$
(resp. $\checkoutr{M}$, $\checkoutr{S}$) from a repository
(resp. object, spine) to a metaclosed object as unfolding the
definitions of all metavariables recursively:
\begin{align*}
  \checkout{\mr} &= \checkoutr{\hat{\mr}} \\
  \checkoutr{\smeta X \sigma} &= \checkoutr{\mr(\smeta X\sigma)}\\
  \checkoutr{\lam x M} &= \lam x \checkoutr{M} \\
  \checkoutr{\app H S} &= \app H {(\checkoutr{S})} \\
  \checkoutr{\spinecons M S} &= \spinecons {\checkoutr M} {\checkoutr S} \\
  \checkoutr{\spinenil} &= \spinenil
\end{align*}

A repository is said to be \emph{well-formed} if $\checkout {\mr}$
is defined.

\begin{theorem}
  If \/ $\jm\mr\Gamma M A \mmr {M'}$ then \/ $\jem\mmr\Gamma M {M'} A$
\end{theorem}

\begin{theorem}
  If \/ $\jm\mr\Gamma M A \mmr {M'}$ then \/ $\jlfm\Gamma {(\checkoutrr
    M)} (\checkoutrr A)$
\end{theorem}

\subsection{The computation calculus}
\label{sec:computational-calculus}

We now turn to the definition of our computation calculus. As we saw,
code is attached to special, \emph{defined} constants in the signature
that manipulates \LF\ objects. We have the ability to construct
objects out of other, and deconstruct them by case analysis:
\begin{align*}
  T &\gequal
  \lam x T \gor
  U \\
  U &\gequal
  F \gor
  \matchin U \Gamma C \\
  C &\gequal \casenobar P U \gor
  C\ \case P U \\
  P &\gequal
  \app H {\var x} \ldots\ {\var x}
\end{align*}

This language is un(i)typed, in that all \LF\ objects are viewed as
having the same implicit type $\cst{obj}$: there is no static
guarantee that terms produced by a constant $\cst c : A_1\to A_2$ will
have type $A_2$. It is also non-terminating: we could declare a
recursive constant $\cst c : \cst a\to \cst a = \lam x \app {\cst c}
{\var x}$. We expose here only the minimal building blocks of this
language, but really any language with algebraic datatypes would do
since we will be manipulating directly the first-order representation
of \LF\ objects. In fact, whatever the language is, you can think of
defined constants as mere black boxes taking and producing terms, and
being able to call other black boxes. We detail for example in section
\ref{sec:implem} how to embed \sysname{OCaml} as computation calculus.

Nevertheless, in order to maintain the well-typing of the generated
term, we want to maintain the invariant that each time a piece of term
goes in or out of a black box, it is checked against its specification
(\ie\ its type). We thus maintain \emph{dynamic typing} of
computations: arguments and results are type-checked at run-time.

\paragraph{Substitution}

\begin{align*}
  \gsubst {(\lam x T)} \sigma &= \lam x {\gsubst T\sigma} \qquad
  \text{if $\var x\notin\dom\sigma$}\\
  \gsubst {(\matchin U \Gamma C)} \sigma &=
  \matchin {\gsubst
    U\sigma} {\gsubst\Gamma\sigma} {\gsubst C\sigma} \\
  \gsubst {(\casenobar{\app H {\spinecons {\var x_1} {\spinecons \ldots {\var
          x_n}}}} U)} \sigma &= {\casenobar{\app H {\spinecons {\var x_1} {\spinecons \ldots {\var
          x_n}}}} \gsubst U \sigma} \quad \text{if $\var x_i\notin\dom\sigma$} \\
\end{align*}

\begin{figure*}
  \fbox{$\jcc\mr\Gamma T S A \mmr F$}
  \qquad
  {Computational cut}

  \begin{mathpar}
    \infer{
      \jm\mr\Gamma M A \mmr {M'}
      \and
      \jcc\mmr\Gamma{\gsubst T {\msubst x M}} S {A_2}\mmmr F
    }{
      \jcc\mr\Gamma{\lam x T}{\spinecons M S}{(\prd x {A_1} {A_2})}
      \mmmr F
    }

    \infer{
      \jcr\mr\Gamma U \mmr F
      \and
      \jm\mmr\Gamma F {\app {\cst a} S} \mmmr {F'}
    }{
      \jcc\mr\Gamma U \spinenil {\app {\cst a} S} \mmmr {F'}
    }
  \end{mathpar}

  \fbox{$\jcr\mr\Gamma U \mmr F$}
  \qquad
  {Computational reduction}

  \begin{mathpar}
    \infer{ }{
      \jcr\mr\Gamma{\app {\var x} S} \mr {\app {\var x} S}
    }

    \infer{
      \Sigma(c) = A; (\annsliceable\text{ or }\annnonsliceable)
    }{
      \jcr\mr\Gamma{\app {\cst c} S} \mr {\app {\cst c} S}
    }

    \infer{
      \Sigma(c) = A; \anndefined T
      \and
      \jcc\mr\Gamma T S A \mmr F
    }{
      \jcr\mr\Gamma{\app {\cst c} S} \mr {\app {\cst c} S}
    }

    \infer{
      \jcr\mr{\gconcat\Gamma{\Gamma'}} U \mmr {\app {H_i} {\spinecons
          {M_1}{\spinecons\ldots{M_{m_i}}}}}
      \and
      \jcr\mmr\Gamma {\gsubst{U_i}{\msubst {x$_1$} {M_1} \ldots\
          \msubst {x$_{m_i}$} {M_{m_i}}}} \mmmr F a
    }{
      \jcr\mr\Gamma{\matchin{U}{\Gamma'}{
          \casenobar{\app {H_1}{\spinecons {\var x_{11}} {\spinecons
                \ldots\ {\var x_{1m_1}}}}}{U_1}
          |\ \ldots\
          \case{\app {H_n}{\spinecons {\var x_{n1}} {\spinecons
              \ldots\ {\var x_{nm_n}}}}}{U_n}
        }}\mmr F
    }

  \end{mathpar}

  \caption{Weak head-reduction}
  \label{fig:whr}
\end{figure*}

\begin{figure*}
  \centering
  TODO
  \caption{Definitional equality}
  \label{fig:def-eq}
\end{figure*}

\section{Implementation}
\label{sec:implem}
\section{Related work}
% 1-2 pages

\section*{Conclusion and future work}
% 0.5 pages

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{abbrvnat}
\bibliography{../../english.bib}


% \begin{thebibliography}{}
% \softraggedright
% \bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
% P. Q. Smith, and X. Y. Jones. ...reference text...
% \end{thebibliography}

\end{document}
