\documentclass[9pt]{sigplanconf}

\usepackage{ntheorem}
\usepackage{amsmath}
\usepackage{amssymb}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\usepackage{macros}
\usepackage{mathpartir}

\begin{document}

\conferenceinfo{LFMTP '12}{September 9, 2012 -- Copenhagen, Denmark}
\copyrightyear{2012}
\copyrightdata{[to be supplied]}

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Certified incremental program transformations}
%\subtitle{Subtitle Text, if any}

\authorinfo{Matthias Puech}
           {Department of Comp. Sci., Univ. of Bologna,\\
             PPS, Team $\pi r^2$ (Univ. Paris Diderot, CNRS, INRIA)}
           {puech@cs.unibo.it}

\authorinfo{Yann R\'egis-Gianas}
           {PPS, Team $\pi r^2$ (Univ. Paris Diderot, CNRS, INRIA)}
           {yrg@pps.jussieu.fr}

\maketitle

\begin{abstract}
\end{abstract}

\category{D.3.3}{Language Constructs and Features}{Data types and
  structures} \category{F.3.1}{Logics and Meanings of
  Programs}{Specifying and Verifying and Reasoning about
  Programs --- Logics of programs}

\terms
Theory, Languages

\keywords
incrementality, type checking, logical framework, version control

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

\section{The calculus}

\subsection{Core calculus}

The core calculus defines the \emph{values} we want to
manipulate. These contain constants, and --- contrarily to \eg\ ML
values --- binders and variables enabling $\lambda$-tree syntax (TODO
cite). Thus, they embed a superficial notion of computation:
hereditary substitution. This calculus is an extension of \emph{spine
  canonical LF} (TODO cite) enriched with metavariables. We present
its typing algorithm relatively to a signature. It features an
explicit caching mechanism using metavariables.

\paragraph{Syntax}

In this variant, only $\eta$-long $\beta$-normal forms have an
existence: canonicity for $\beta$-reduction is enforced in the syntax;
canonicity for $\eta$-expansion will be enforced by typing. Also,
application of a \emph{head} to a \emph{spine} (\ie\ a constant or
variable) is $n$-ary as opposed to the more standard binary
application: this eases reasoning about substitution and
$\eta$-expansion (TODO cite).

\begin{align*}
  K &\gequal
  \prd x A K \gor
  \type &
  \text{Kind}\\
  A &\gequal
  \prd x A A \gor
  \app {\cst a} S &
  \text{Type family} \\
  M &\gequal
  \lam x M \gor
  F \gor
  \smeta X \sigma &
  \text{Object} \\
  F &\gequal \app H S &
  \text{Application} \\
  H &\gequal
  \var x \gor
  \cst c &
  \text{Head}\\
  S &\gequal
  \spinenil \gor
  \spinecons M S &
  \text{Spine}\\
  \sigma &\gequal
  \msubstnil \gor
  \msubstcons \sigma x M &
  \text{Parallel substitution} \\
  \Gamma &\gequal
  \envnil \gor
  \envcons \Gamma x A &
  \text{Environment}
\end{align*}

As is customary, we adopt the Barendregt convention for naming bound
variables, write $\meta X$ for $\smeta X \msubstnil$, $A\to B$ for
$\prd x A B$ when $x\notin \FV{B}$ and adopt list notations for $S,
\sigma, \Gamma, \Sigma$ when convenient.

Metavariables $\smeta X \sigma$ stand for open objects with free
variables in $\dom{\sigma}$; they are defined in a repository (see
below). We write $\FMV{M}$ for the set of metavariables in $M$ and
speak of a \emph{metaclosed} object $M$ if $\FMV{M} = \emptyset$.

\paragraph{Substitution}

We overload \emph{substitution} as a partial operation on terms, given
a parallel substitution $\sigma$. Since the syntax of object is not
stable by (textual) substitution, it is defined \emph{hereditarily}: it
is mutually recursive with a \emph{cut} function $\gcut M S$ which can
in turn trigger a chain of substitutions, leading to a canonical term,
a stuck substitution or divergence. % TODO vraiment?
\begin{align*}
  \gsubst {(\lam x M)} \sigma &= \lam x {\gsubst M \sigma} &
  \text{if $x\notin \dom{\sigma}$}
  \\
  \gsubst {(\app {\cst c} S)} \sigma &= \app {\cst c} {(\gsubst S
    \sigma)}
  \\
  \gsubst {(\app {\var x} S)} \sigma &=
  \app {\var x} {\gsubst S \sigma} &
  \text{if $x\notin \dom{\sigma}$}
  \\
  \gsubst {(\app {\var x} S)} \sigma &=
  \gcut M {\gsubst S \sigma} &
  \text{if $\sigma(x) = M$}
  \\
  \gsubst {\smeta X {\sigma}} {\sigma'} &=
  \smeta X {\gcomp\sigma{\sigma'}}
  \\
  \gsubst\spinenil\sigma &=
  \spinenil \\
  \gsubst{\spinecons M S}\sigma &=
  \spinecons{\gsubst M\sigma}{\gsubst S\sigma}
  \\
  \gcut {\lam x M} {\spinecons N S} &=
  \gcut {\gsubst M N} S
  \\
  % TODO cas meta/S ????
  % \gcut {\smeta X\sigma} S &=
  % \smeta X{\gcomp\sigma\sigma'}
  % \\
  \gcut {\app H S} \spinenil &=
  \app H S
  \\
  \gcut {\smeta X\sigma} \spinenil &= \smeta X\sigma
  \\
  \gcomp \sigma \msubstnil &=
  \sigma
  \\
  \gcomp \sigma {(\msubstcons{\sigma'} x M)} &=
  \gcomp {\gsubst\sigma {\msubst x M}} \sigma'
  \\
  \gsubst {(\msubstcons{\sigma'} x M)} \sigma &=
  \msubstcons{\gsubst{\sigma'}\sigma} x {\gsubst M \sigma}
  \\
  \gsubst {\msubstnil}{\sigma} &= \msubstnil
\end{align*}

We extend this operation trivially on families $\gsubst A \sigma$ and
kinds $\gsubst K \sigma$. We also allow to abusively write the
non-canonical application $\app M S$ as a shorthand for $\gcut M S$ if
it is defined.

Note that this notion of substitution presupposes $\eta$-long normal
forms: a non-empty spine cut against to another non-empty spine $\gcut
{\app H S} {S'}$ blocks the substitution.

% TODO pourquoi cette def?
% TODO terminaison??
% TODO stabilit√© de la eta?

\paragraph{Typing algorithm}

Typing an object while storing intermediate derivations requires
threading and maintaining a data structure of named partial
derivations (a repository) throughout the typing process. We present a
bidirectional typing algorithm updating an input repository.

A \emph{repository} $\mr$ is a finite map from metavariable to
judgements of object well-typing, along with a distinguished
metavariable, the \emph{head}:
$$ \mr\;:\;(\meta X \mapsto (\Gamma\vdash\tp M A)), \smeta X \sigma $$
We maintain the invariant that a repository $\mr$ is
\emph{acyclic}, that is for all $\meta X$ in $\mr$, the fixpoint
of $\FMV{\meta X}$ does not contain $\meta X$. With $\mr =
(\Delta, X[\sigma])$, we write $\hat {\mr}$ for $X[\sigma]$,
abusively $\mr$ for $\Delta$ and $\mr (\smeta X \sigma)$ for
$\gsubst M\sigma$ if $\Delta(\meta X) = (\Gamma\vdash M : A)$.

A \emph{signature} declares object and type constants to be used in
objects:
$$
\Sigma \gequal
\gnil \gor
\gcons \Sigma {\cst c : A} \gor
\gcons \Sigma {\cst a : K} \qquad
\text{Signature}
$$

The algorithm is presented in Fig. \ref{fig:typing-algo} as a
syntax-directed inference system. All judgements are of the form $\gj
U V W$ where $U$ and $V$ are inputs, $V$ is the induction hypothesis
and $W$ the output. They are parameterized by a constant and implicit
signature $\Sigma$.

\begin{figure*}

  \fbox{$\jm\mr\Gamma M A \mmr {M'}$}
  \qquad
  Object typing

  \begin{mathpar}
    % Lambda
    \infer{
      \jm\mr{\envcons\Gamma x A} M {A'} \mmr {M'}
    }{
      \jm\mr\Gamma {\lam x M} {\prd x A {A'}} \mmr {\lam x M'}
    }

    % App
    \infer{
      \jf\mr\Gamma F \mmr {M'} {A'}
       \and
      \jea\mmr\Gamma A {A'}
    }{
      \jm\mr\Gamma F A \mmr {M'}
    }

    % Meta
    \infer{
      \mr(\meta X) = (\Gamma'\vdash M:A')
      \and
      \js\mr\Gamma \sigma {\Gamma'} \mmr {\sigma'}
      \and
      \jea\mmr\Gamma A {\gsubst {A'} {\sigma'}}
    }{
      \jm\mr\Gamma {\smeta X \sigma} A \mmr {M'}
    }
  \end{mathpar}

  \fbox{$\js\mr\Gamma\sigma{\Gamma'}\mmr{\sigma'}$}
  \qquad
  {Substitution typing}

  \begin{mathpar}

    % Cons
    \infer{
      \js\mr\Gamma\sigma{\Gamma'}\mmr{\sigma'}
      \and
      \jm\mmr\Gamma M {\gsubst A {\sigma'}} \mmmr {M'}
    }{
      \js\mr\Gamma{(\msubstcons \sigma x M)} {(\envcons {\Gamma'} x {A'})}
      \mmmr {(\msubstcons {\sigma'} x {M'})}
    }

    % Nil
    \infer{ }{
      \js\mr\Gamma\msubstnil\envnil\mr\envnil
    }

  \end{mathpar}

  \caption{Typing algorithm}
  \label{fig:typing-algo}
\end{figure*}


\paragraph{Checkout}

We define the partial \emph{checkout} operation $\checkout{\mr}$
(resp. $\checkoutr{M}$, $\checkoutr{S}$) from a repository
(resp. object, spine) to a metaclosed object as unfolding the
definitions of all metavariables recursively:
\begin{align*}
  \checkout{\mr} &= \checkoutr{\hat{\mr}} \\
  \checkoutr{\smeta X \sigma} &= \checkoutr{\mr(\smeta X\sigma)}\\
  \checkoutr{\lam x M} &= \lam x \checkoutr{M} \\
  \checkoutr{\app H S} &= \app H {(\checkoutr{S})} \\
  \checkoutr{\spinecons M S} &= \spinecons {\checkoutr M} {\checkoutr S} \\
  \checkoutr{\spinenil} &= \spinenil
\end{align*}

A repository is said to be \emph{well-formed} if $\checkout {\mr}$
is defined.

\subsection{The computation calculus}

We now turn to the definition of our computation calculus on LF
objects. This language is untyped. % TODO??
\begin{align*}
  T &\gequal
  F \gor
  \matchin T \Gamma \casenobar P T\ |\ \ldots\ \case P T \\
  P &\gequal \app {\cst c} {\vec x}
\end{align*}

We extend our notion of signature to allow object constants to embed a
computational behaviour.

$$  \Sigma \gequal
  \ldots \gor
  \gcons \Sigma {\cst c : A = T}
  \qquad
  \text{Signature}
$$

\section{Implementation}

\section{Examples}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{abbrvnat}
\bibliography{../../english.bib}


% \begin{thebibliography}{}
% \softraggedright
% \bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
% P. Q. Smith, and X. Y. Jones. ...reference text...
% \end{thebibliography}

\end{document}
