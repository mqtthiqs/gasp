\documentclass[9pt]{sigplanconf}

\usepackage{ntheorem}
\usepackage{amsmath}
\usepackage{amssymb}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\usepackage{macros}

\begin{document}

\conferenceinfo{LFMTP '12}{September 9, 2012 -- Copenhagen, Denmark}
\copyrightyear{2012}
\copyrightdata{[to be supplied]}

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Certified incremental program transformations}
%\subtitle{Subtitle Text, if any}

\authorinfo{Matthias Puech}
           {Department of Comp. Sci., Univ. of Bologna,\\
             PPS, Team $\pi r^2$ (Univ. Paris Diderot, CNRS, INRIA)}
           {puech@cs.unibo.it}

\authorinfo{Yann R\'egis-Gianas}
           {PPS, Team $\pi r^2$ (Univ. Paris Diderot, CNRS, INRIA)}
           {yrg@pps.jussieu.fr}

\maketitle

\begin{abstract}
\end{abstract}

\category{D.3.3}{Language Constructs and Features}{Data types and
  structures} \category{F.3.1}{Logics and Meanings of
  Programs}{Specifying and Verifying and Reasoning about
  Programs --- Logics of programs}

\terms
Theory, Languages

\keywords
incrementality, type checking, logical framework, version control

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

\section{The calculus}

\subsection{Core calculus}

The core calculus defines the \emph{values} we want to
manipulate. These contain constants, and --- contrarily to \eg\ ML
values --- binders and variables enabling $\lambda$-tree syntax (TODO
cite). Thus, they embed a superficial notion of computation:
hereditary substitution. This calculus is an extension of \emph{spine
  canonical LF} (TODO cite) enriched with metavariables. We present
its typing algorithm relatively to a signature. It features an
explicit caching mechanism using metavariables.

\paragraph{Syntax}

In this variant, only $\eta$-long $\beta$-normal forms have an
existence: canonicity for $\beta$-reduction is enforced in the syntax;
canonicity for $\eta$-expansion will be enforced by typing. Also,
application of a \emph{head} to a \emph{spine} (\ie\ a constant or
variable) is $n$-ary as opposed to the more standard binary
application: this eases reasoning about substitution and
$\eta$-expansion (TODO cite).

\begin{align*}
  K &\gequal
  \prd x A K \gor
  \type &
  \text{Kind}\\
  A &\gequal
  \prd x A A \gor
  \app {\cst a} S &
  \text{Type family} \\
  M &\gequal
  \lam x M \gor
  F \gor
  \smeta X \sigma &
  \text{Object} \\
  F &\gequal \app H S &
  \text{Application} \\
  H &\gequal
  \var x \gor
  \cst c &
  \text{Head}\\
  S &\gequal
  \spinenil \gor
  \spinecons S M &
  \text{Spine}\\
  \sigma &\gequal
  \msubstnil \gor
  \msubstcons \sigma x M &
  \text{Substitution} \\
  \Gamma &\gequal
  \gnil \gor
  \gcons \Gamma {\tp {\var x} A} &
  \text{Environment}
\end{align*}

As usual, we write $\meta X$ for $\smeta X \msubstnil$, $A\to B$ for
$\prd x A B$ when $x\notin \FV{B}$ and adopt list notations for $S,
\sigma, \Gamma, \Sigma$ when convenient.

Metavariables $\smeta X \sigma$ stand for open objects with free
variables in $\dom{\sigma}$; they are defined in a repository (see below). We
write $\FMV{M}$ for the set of metavariables in $M$.

\paragraph{Substitution}

We overload \emph{substitution} as a partial operation on terms, given
a parallel substitution $\sigma$. Since the syntax of object is not
stable by substitution, it is defined \emph{hereditarily}: it is
mutually recursive with a \emph{normalization} function $\gcut M S$
which can in turn trigger a chain of substitutions, leading to a
canonical term, a stuck substitution or divergence. % TODO vraiment?
\begin{align*}
  \gsubst {(\lam x M)} \sigma &= \lam x {\gsubst M \sigma} &
  \text{if $x\notin \dom{\sigma}$}
  \\
  \gsubst {(\app {\cst c} S)} \sigma &= \app {\cst c} {(\gsubst S
    \sigma)}
  \\
  \gsubst {(\app {\var x} S)} \sigma &=
  \app {\var x} {\gsubst S \sigma} &
  \text{if $x\notin \dom{\sigma}$}
  \\
  \gsubst {(\app {\var x} S)} \sigma &=
  \gcut M {\gsubst S \sigma} &
  \text{if $\sigma(x) = M$}
  \\
  \gsubst {\smeta X {\sigma}} {\sigma'} &=
  \smeta X {\gcomp\sigma{\sigma'}}
  \\
  \gsubst\spinenil\sigma &=
  \spinenil \\
  \gsubst{\spinecons S M}\sigma &=
  \spinecons{\gsubst S\sigma}{\gsubst M\sigma}
  \\
  \gcut {\lam x M} {\spinecons N S} &=
  \gcut {\gsubst M N} S
  \\
  % TODO cas meta/S ????
  % \gcut {\smeta X\sigma} S &=
  % \smeta X{\gcomp\sigma\sigma'}
  % \\
  \gcut {\app H S} \spinenil &=
  \app H S
  \\
  \gcomp \sigma \msubstnil &=
  \sigma
  \\
  \gcomp \sigma {(\msubstcons{\sigma'} x M)} &=
  \gcomp {\gsubst\sigma {\msubst x M}} \sigma'
  \\
  \gsubst {(\msubstcons{\sigma'} x M)} \sigma &=
  \msubstcons{\gsubst{\sigma'}\sigma} x {\gsubst M \sigma}
  \\
  \gsubst {\msubstnil}{\sigma} &= \msubstnil
\end{align*}

Note that this notion of substitution presupposes $\eta$-long normal
forms: a spine applied to another application $\gcut {\app H S} {S'}$
blocks the substitution.

We extend this operation trivially on families $\gsubst A \sigma$
and kinds $\gsubst K \sigma$

% TODO terminaison??
% TODO stabilit√© de la eta

\paragraph{Typing algorithm}

A \emph{repository}
is a finite map from metavariable to judgements of object well-typing,
along with a distinguished metavariable, the \emph{head}:
$$ \repo R\;:\;(\meta X \mapsto (\Gamma\vdash\tp M A)), \smeta X \sigma $$
We maintain the invariant that a repository $\repo R$ is
\emph{acyclic}, that is for all $\meta X$ in $\repo R$, the fixpoint
of $\FMV{\meta X}$ does not contain $\meta X$.

A \emph{signature} declares object and type constants to be used in
objects:
$$  \Sigma \gequal
  \gnil \gor
  \gcons \Sigma {\cst c : A} \gor
  \gcons \Sigma {\cst a : K} \qquad
  \text{Signature}
$$

\subsection{The computation calculus}

We now turn to the definition of our computation calculus on LF
objects. This language is untyped
\begin{align*}
  T &\gequal
   M \gor
  \match T \casenobar P T\ |\ \ldots\ \case P T \\
  P &\gequal \app {\cst c} {\vec x}
\end{align*}

We extend our notion of signature to allow object constants to embed a
computational behaviour.

$$  \Sigma \gequal
  \ldots \gor
  \gcons \Sigma {\cst c : A = T}
  \qquad
  \text{Signature}
$$


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{abbrvnat}
\bibliography{../../english.bib}


% \begin{thebibliography}{}
% \softraggedright
% \bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
% P. Q. Smith, and X. Y. Jones. ...reference text...
% \end{thebibliography}

\end{document}
