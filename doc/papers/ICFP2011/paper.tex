\documentclass[preprint]{sigplanconf}

\usepackage{amsmath}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[usenames,dvipsnames]{color}
\usepackage[pdftex,backref=page,colorlinks=true]{hyperref}

\definecolor{bwgreen}{rgb}{0.183,1,0.5}
\definecolor{bwmagenta}{rgb}{1,0.169,0.909}
\definecolor{bwblue}{rgb}{0.317,0.161,1}
\hypersetup{
  linkcolor=blue,
  citecolor=blue
}

% Remarks
\newcommand\rem[2]{\textcolor{Mahogany}{{\textsf{#1}} $\triangleright$
    \textsl{#2}}}
\newcommand\mrem[1]{\rem{M}{#1}}
\newcommand\yrem[1]{\rem{Y}{#1}}

% Grammars
\newcommand\gor{\ |\ }
\newcommand\gequal{\ ::=\ }

% Variables
\newcommand\meta[1]{\ensuremath\textsc{#1}}

% Terms
\newcommand\postbinder{\cdot}
\newcommand\prd[2]{\ensuremath\Pi{#1}^{#2}\postbinder}
\newcommand\prdi[1]{\ensuremath\forall{#1}\postbinder}
\newcommand\app[1]{{#1}\ }
\newcommand\tlam[2]{\ensuremath\lambda{#1}^{#2}\postbinder}
\newcommand\ulam[1]{\ensuremath\lambda{#1}\postbinder}
\newcommand\letb[2]{\ensuremath\mathsf{let}\ {#1}={#2}\ \mathsf{in}\ }
\newcommand\lam{\tlam}
\newcommand\obox[3]{\ensuremath\{{#1}\}^{#2}_{#3}}

% Sorts
\newcommand\srt[1]{\ensuremath\mathsf{#1}}
\newcommand\type{\srt *}
\newcommand\kind{\srt \Box}

% Sequent-like application
\newcommand\lapp[2]{{#1}[{#2}]}
\newcommand\laapp[3]{{#1}[{#2}]:{#3}}
\newcommand\lnil{\cdot}
\newcommand\lcons[2]{{#1};{#2}}
\newcommand\lncons[3]{{#1}={#2};{#3}}

%Environments
\newcommand\enil\cdot
\newcommand\eent[1]{\left[{#1}\right]}
\newcommand\econs[2]{{#1}\eent{#2}}
\newcommand\esing[1]{\econs{}{#1}}
\newcommand\emerge[2]{{#1}\cdot{#2}}
\newcommand\elookup[2]{{#1}({#2})}
\newcommand\elookupdef[3]{{#1}({#2}) = {#3}}
\newcommand\elookupdecl[3]{{#1}({#2}) : {#3}}
\newcommand\ebind[2]{\econs{#1}{#2}}
\newcommand\ebinddef[3]{\econs{#1}{{#2}={#3}}}
\newcommand\ebinddecl[3]{\econs{#1}{{#2}:{#3}}}
\newcommand\edecls[1]{\mathsf{decls}({#1})}
\newcommand\edefs[1]{\mathsf{defs}({#1})}


% Term operations
\newcommand\subst[2]{\{{#1}/{#2}\}}
\newcommand\repl[2]{\subst{#1}{{#2}}}
\newcommand\conv{\equiv}

% Judgements
\newcommand\jlang[3]{{#2}\vdash_{\mathrm{#1}}{#3}}
\newcommand\jlangt[4]{{#2}\vdash_{\mathrm{#1}}{#3}:{#4}}
\newcommand\jlangA[3]{{#2}\vdash_{\mathrm{#1}}{#3}\mathsf{\ type}}
\newcommand\jlangK[3]{{#2}\vdash_{\mathrm{#1}}{#3}\mathsf{\ kind}}

\newcommand\jlft[3]{\jlangt{LF}{#1}{#2}{#3}}
\newcommand\jlfA[2]{\jlangA{LF}{#1}{#2}}
\newcommand\jlfK[2]{\jlangK{LF}{#1}{#2}}

\newcommand\jxlft[3]{\jlangt{XLF}{#1}{#2}{#3}}
\newcommand\jxlfA[2]{\jlangA{XLF}{#1}{#2}}
\newcommand\jxlfK[2]{\jlangK{XLF}{#1}{#2}}

\newcommand\jnlft[3]{\jlangt{}{#1}{#2}{#3}}
\newcommand\jnlfA[2]{\jlangA{}{#1}{#2}}
\newcommand\jnlfK[1]{{#1}\ \mathsf{kind}} %on peut pas utiliser \jlangK

\newcommand\jnlfargs[3]{\jnlft{#1}{#2}{#3}}
\newcommand\jnlfconvA[3]{\jnlfA{#1}{{#2}\conv{#3}}}
\newcommand\jnlfconvt[4]{\jnlft{#1}{{#2}\conv{#3}}{#4}}
\newcommand\jnlfconve[3]{\jlang{}{#1}{{#2}\conv{#3}}}

% simple judgements with no environments (NLF)
\newcommand\jwf[1]{{#1}\ \mathsf{wf}}

% Animations
\newcommand\alta[4]{\alt<-#1>{#3}{\alert<#2>{#4}}}
\newcommand\uncovera[2]{\uncover<#1->{\alert<#1>{#2}}}
\newcommand\onlya[2]{\only<#1->{\alert<#1>{#2}}}

% Various
\newcommand\gray[1]{\textcolor{gray}{#1}}
\newcommand\cit[1]{[\textcolor{blue}{#1}]}
\newcommand\To{\Rightarrow}
\newcommand\too{\longrightarrow}
\newcommand\Too{\Longrightarrow}
\newcommand\nat{\mathbb N}
\newcommand\FV[1]{\mathsf{FV}({#1})}
\newcommand\notinfv[2]{{#1}\notin\FV{#2}}

\newcommand\itplus{\textcolor{green!60!black}{\textbf{\textsf{+}}}}
\newcommand\itminus{\textcolor{red}{\textbf{\textsf{--}}}}

\newenvironment{smallright}{
  \begin{flushright}
    \footnotesize
  }{
  \end{flushright}
}


\begin{document}

\conferenceinfo{ICFP '11}{September 19--21, Tokyo, Japan}
\copyrightyear{2011}
\copyrightdata{[to be supplied]}

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Incremental type-checking}
%\subtitle{Subtitle Text, if any}

\authorinfo{Matthias Puech}
           {University of Bologna, University Paris Diderot}
           {puech@cs.unibo.it}
\authorinfo{Yann Régis-Gianas}
           {University Paris Diderot, CNRS, and INRIA}
           {yrg@pps.jussieu.fr}

\maketitle

\begin{abstract}

%% Four sentences:
%% State the problem
%% Say why it’s an interesting problem
%% Say what your solution achieves
%% Say what follows from your solution

\end{abstract}

\category{CR-number}{subcategory}{third-level}

\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}

%% Describe the problem (Use an example)
%% State your contributions (Bulleted list of contributions)

% \mrem{Une intro que j'avais écrit il y a longtemps et que je sais
%   pas où mettre. Sûrement à jeter\ldots}

% Programs are nowadays faster to write and safer to execute, thanks to
% high-level programming concepts and expressive type systems. Still,
% one aspect of programming didn't change very much---if not at
% all---since the early days of high-level programming: we still write
% programs in text files and when we are done, we let the compiler check
% and compile them.  Though, every programmer knows that writing a
% program longer than a few dozen of lines is a highly non-linear task
% involving constant experiments, fixes, rollback on previous
% modifications etc., all of those eventually validated by some a
% posteriori criterion: execution and ``empirical'' test, and
% increasingly complex type-checking and type inference. In a nutshell,
% programmers spend more time \emph{editing} than \emph{writing}. Yet,
% this aspect of their day-to-day workflow is not, or poorly taken into
% account in a developer's toolchain:
% \begin{itemize}
% \item To avoid recompiling a whole program upon a change, we split
%   them into files, and (re-)compile them separatly. Very often yet,
%   this separation serve different purpose: abstraction, splitting into
%   logical units, namespace management\ldots\ Why should these purposes
%   coincide?

% \yrem{On propose quelque chose d'encore plus extreme: faire descendre
% les VCS dans le type-checker. Voir deux paras plus loin.}

% \item To keep track of past versions of a program, we use text-based
%   version control systems that have no awareness of the actual content
%   of the file. In a sense, the non-linearity of the task is managed
%   outside the scope of the language, by manual, textual
%   transformations. Isn't there a lot to gain in making these tools
%   syntax-aware, even semantics-aware?

% \yrem{Je comprends mais je ne sais pas trop ou tu veux en venir.}

% \item As a result, all the semantic information that could be
%   available to the programmer and act as a \emph{guidance tool} to
%   write programs (e.g. type informations) are only used by the
%   type-checker as a \emph{repressive} measure against programming
%   errors (type errors).
% \end{itemize}

% These observations apply to the usual, wide-spread programming
% languages, but even if the current toolchain in use up to now was a
% reasonable approximation to the incremental interaction with the
% compiler intended by the user, they become \emph{a fortiori} necessary
% when it come to the new, demanding languages embedding formal
% verification aspects, like proof assistants or programming languages
% with rich type system. In these emerging languages, interaction with a
% type- or proof-checker is unavoidable due to the difficulty of writing
% correct proofs without guidance from the system, and the constant
% modification of the source makes necessary to observe incrementally
% the effect of a small change on the whole edifice. Moreover, as the
% complexity of the object to check increases, we cannot afford anymore
% to rely on the usual unit of compilation, the file, a need a
% finer-grained tool. 

% \yrem{On pourrait parler de l'utilisation de l'incrementalite pour le type-checking
% parallele et aussi pour le developpement concurrent.}

% Current text-based version control technology is designed to help
% concurrent and collaborative development but are not used inside
% compilers or proof checkers. There is a good reason for that: a
% representation of changes at the textual level is not structured
% enough to be used easily and efficiently by such symbolic tools. They
% need instead a more structured representation of changes with a clear
% meaning with respect to the language semantics. For instance, if a
% formal argument of a function has been renamed in a source file
% edition, a textual representation would refer to a change in every
% line that contains an occurrence of that formal argument. A proof
% kernel would prefer a higher level description of that edition from
% which it would be simple to deduce that no proof has to be rechecked
% because the old and the new version of the development are
% $\alpha$-equivalent.

% \yrem{Prochain para: LF. Finir sur les petits problemes de LF.}

% % Expliciter clairement les contributions du papier:
% % Une extension de LF avec des variables meta + lambda-selecteur-de-boite. (SLF)
% % Un langage pour representer efficacement un ensemble de termes validés. (NLF)
% % Une compilation de SLF vers NLF qui vérifie le bon typage.
% % Un typage incrémental par proof-search dans NLF.
% % La méta-théorie de NLF qui pose des bases pour la formalisation des VCS sémantiques.
% % Un prototype.

% We propose to devise here a data structure for repositories of
% programs and proofs allowing to take advantage of the incremental
% nature of a programmer's workflow.

\section{Incremental type-checking} % (1 page)

%% Here is a problem

\subsection{Why specialize incremental computation?}
%% It’s an unsolved problem

\subsection{Applications}
%% It’s an interesting problem

\section{Why a logical framework?} % (2 pages)
%% Here is my idea

\subsection{The essence of memoization}

\subsection{A metalanguage for sharing derivations}

% exemple en SLF

% Presentation de NLF.

\section{Repository data-structure and interaction}

%% My idea works (details, data)

\subsection{Architecture of the system}

\subsection{From LF to NLF}

\subsubsection{The source language}

\begin{figure}
  \centering
  \begin{align*}
    K &\gequal { \prd x A K \gor \type } \\
    A &\gequal { \prd x A A \gor \lapp A l } \\
    t &\gequal { \lam x A t \gor \lapp h l \gor \meta x \gor \obox t x
      \sigma } \\
    h &\gequal { t \gor c \gor x } \\
    l &\gequal { \lnil \gor \lcons t l }
  \end{align*}
\end{figure}

\subsubsection{Typing annotation}

\subsubsection{Non-positional calculus}

\subsection{Interaction with a repository}

% Metathéorie de NLF

% Applications (typage incrémental, quelques premières pistes pour commit/merge)

\section{Related works} % (1-2 pages)

%% Here’s how my idea compares to other people’s approaches


% Related works (1-2 pages) (à ne surtout pas négliger!)

\section{Conclusion} % (0.5 page)

% Conclusion and further work (0.5 page)
% Dans le future work, en vrac:
%    - un meta-langage au dessus de NLF = un langage de tactique typé pour Coq?
%    - des algorithmes de parsing incrémentaux
%    - modélisation des conflits et de leur résolution dirigée par des types.
%    - intégration dans Coq pour la parallélisation du noyau. 
%   -  certification du checker pour être intégré dans le noyau de Coq 
\bibliographystyle{abbrvnat}

\end{document}
