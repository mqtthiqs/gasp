Sat Jan 16, 2010  7:21 PM 

Plus je réfléchis aux patchs sémantiques et plus je me dis que le bon
cadre de développement est effectivement Coq. 

Si on prend le point de vue très général qui consiste à voir
les dérivations de typage comme n'importe quel inductif dans
Type (de façon à en avoir une représentation enregistrable 
sur un support physique) et qu'on voit les patchs atomiques
comme des appels à des lemmes écrits en Coq (dont le
type est un transformateur), alors la difficulté de la 
conception d'un système de patchs consiste essentiellement
à la définition dans langage de programmation capturant
les transformations utiles au développement d'un programme
(qui a un aspect un peu plus "méta" que la programmation). 

Voici une proposition simple pour ce langage mais qui
pose déjà des problèmes intéressants. On voit
un programme dans ce langage comme un transformateur
de répositoire/mémoire associant des dérivations à des
emplacement. On a alors l'interprétation suivante 
des trois opérations standards: 

- ref e  : alloue un emplacement frais contenant
  la dérivation de typage ∇.
- ! e    : lit un emplacement.
- x := e : écrit dans un emplacement.

C'est la troisième opération qui est intéressante puisque, pour
préserver le fait que la mémoire peut être interprétée comme une
dérivation de typage correcte, il faut s'assurer que les utilisateurs
de 'x' sont toujours satisfaits. Pour cela, on peut produire des
sous-buts, à la manière des tactiques de Coq. On obtient une sorte de
jeu.  Pour traiter ces sous-buts automatiquement, on peut imaginer
comparer l'ancienne et la nouvelle version de "x" et déduire des
transformations canoniques, lorsqu'elle existe.

Par exemple, si on rajoute un nouveau constructeur dans un ADT, on
peut vouloir rajouter une branche avec un lancement d'exception sur
tous les patterns matchings de ce type. Si on rajoute un nouvel
argument à une fonction, tous les utilisateurs de cette fonction
peuvent être appliqué à une valeur par défaut. Il y a aussi cette
transformation de passage de "map" à "foldmap" (qui doit avoir une
définition catégorique):

let map f = function
| [] -> []
| x :: xs -> (f x) :: map f xs

en 

let fold f accu = function
| [] -> accu, []
| x :: xs ->
  let x', accu = f x accu in
  let accu, xs' = fold f accu xs in
  (accu, x' :: xs')

C'est le passage du type "a -> b" au type "a * c -> b * c"
dont parlait Paul-Andre l'autre fois. L'argument "c" 
suit le flot d'exécution. Quelle est la transformation
similaire qui préserve le tail-call?

On doit pouvoir programmer un interprète pour ce langage en Coq.

La mémoire Δ contiendrait des sommes dépendentes de la forme
Σ T: S. φ (T) où φ est une fonction qui transforme S,
la signature de l'algèbre des objets syntaxiques de 
la théorie (ça peut être un jugement, un environnement,
un terme, peu importe). Une procédure de décision sur
ces objets est du type D ≡ list T -> bool. 

Du coup, les transformateurs ont des types de la forme Θ ≡ list T *
list D * list T, qu'on peut facilement interpréter dans Type. De cette
façon, on élimine le problème d'extensibilité: il suffit de
dynamiquement intégrer un nouveau méta-théorème dans l'environnement
du langage de patchs pour que cela fonctionne. 

Le système de type du langage de patchs obtenu est simple. 

Fri Jan  8, 2010  3:51 PM 

Matthias a présenté son système à base de deux jugements : Δ | t, qui
signifie "je peux construire une dérivation t à partir de mes faits Δ"
et Δ | t → u, "je peux construire une dérivation pour u à partir de
la dérivation de t et de la base de faits Δ". 

Le système est joli mais on a remarqué une certaine redondance : il y
a par exemple une règle d'introduction de la partie gauche d'une
application pour le jugement qui a une flèche et une règle de typage
pour l'application pour le jugement "Δ | t". 

En fait, se focaliser sur une dérivation particulière introduit
une certaine asymétrie : on travaille sur une dérivation particulière
qui n'a rien de plus qu'une autre dérivation de la base Δ. Pourquoi
ne pas travailler directement sur plusieurs dérivations à la fois 
et se permettre d'en déduire plusieurs dérivations? On a donc
adapté le système avec cette idée en introduisant un unique 
jugement : Δ ⊧ Δ' où Δ représente les dérivations qu'on a déjà 
sous la main et Δ' les dérivations que l'on déduit. 

Les règles de typage sont des axiomes de ce système, ainsi que les
métathéorèmes (en particulier, les très utiles "lemmes d'inversion").
La théorie des patchs (paramétrée par le langage) a donc une mission
d'administration des dérivations de typage. Le langage des patchs
décrit des constructions de dérivations (à partir d'autres). A priori,
l'expressivité des constantes est peu limitée, en termes opérationnels
(on peut itérer sur une dérivation pour réécrire les environnements de
jugement). Par contre, l'expressivité du langage de patchs est limitée
puisque c'est un langage dont seule la sémantique statique nous
intéresse vraiment (On pourrait imaginer associer une sémantique
opérationnelle qui réaliserait réellement les constructions
de dérivation de typage de bas-niveau mais si on travail dans Coq,
on a la garantie qu'on ne fait rien de mal.)

Il devrait exister un système de types/une analyse statique
intéressant(e) pour le langage des patchs qui permettrait de donner un
sens à des transformations mais non pas sur des dérivations de typage
sur des patchs eux-mêmes. En effet, les transformations tels que
l'évolution d'un répositoire (qui est un patch) en une nouvelle
version de ce répositoire est un patch! On doit donc, d'une certaine
façon, pouvoir bootstrapper le système. 

Revenons à des choses plus concrètes. Matthias a remarqué que le
jugement "Δ ⊧ Δ'" gagne, certes, en symétrie mais on voit moins bien
ce sur quoi s'applique le patch. En particulier, lorsque les patchs
avec une unique conclusion, on pouvait les décrire à l'aide d'un terme
du langage objet (éventuellement étendu par plongement des
métathéorèmes comme des opérateurs constants). Il semble plus
difficile de jouer avec la syntaxe de cette façon dans le nouveau
système.

Quels sont les prochains objectifs? Je pense qu'il faut avoir ce que
l'on a dit en tête mais se focaliser sur un langage particulier (STLC
par exemple). Je ressens vraiment le besoin d'obtenir un prototype
(soit écrit en Caml ou extrait de Coq) et de pouvoir réellement
(méta-)programmer avec ce système. 

Mon Jan  4, 2010  3:22 PM [semantic patch]

Discussion avec Matthias à propos des patchs sémantiques. Il a
formalisé plusieurs systèmes (en Coq et en Agda) qui énumèrent des
transformations possibles sur des dérivations de typage (préservant la
bonne formation de celles-ci).

Le premier système contient des transformations sur la syntaxe basées
sur les règles dirigées par la syntaxe ainsi que des règles de passage
aux contextes.

Le système final contient des transformations avec mémoire,
c'est-à-dire permettant de nommer des dérivations (et les réutiliser
plus tard). Ce système subsume le précédent.

Ce système semble prometteur : en le codant en Coq et en définissant
une base de hints, Matthias a été capable de vérifier des théorèmes
admissibles automatiquement. Il a pensé rajouter des récurseurs (ou
des opérateurs similaires à ceux des langages de stratégies, comme
Stratego).

Matthias a aussi pu constater une certaine méthodologie pour déduire
automatiquement des règles de transformations à partir des règles
dirigées par la syntaxe. La notion de "méta-théorème" constructif
lui semble aussi de plus en plus naturelle.

Les prochaines étapes :
- vérifier que les bindeurs fonctionnent bien ;
- prendre en compte le contexte et la spécification (i.e. le jugement
 tout entier) ;
- valider un système permettant d'écrire les règles d'affaiblissement
 et de renforcement du contexte.



Fri Dec 18, 2009  3:39 PM

Matthias a posé la question de la vérification de l'application
d'un métathéorème. 

Par exemple, le renommage R[x -> y] s'applique bien sur le 
terme [let x = e1 in e2] mais pas sur le theme [e1].

Est-ce qu'on peut trouver un système de types intéressant pour
vérifier la bonne application de R ?

Yann répond : il suffit d'utiliser Coq mais, c'est un peu facile
comme réponse :). 

Mon Dec 14, 2009  6:29 PM

Une transformation non triviale qui apparait souvent :

let rec f x = 
  ... g y ...
and g y = 
  ... f x ...

devient :

let rec f env x = 
 ... g env y ...
and g env y = 
 ... f env x ...

(ou bien interaction a l'aide d'un '?')
