Sun Jan 17, 2010  9:47 AM

Au sujet de la visualisation d'une dérivation à offrir au programmeur,
ce n'est pas évident. A première vue, je pensais qu'il suffisait de se
donner une (ou plusieurs) syntaxe(s) pour visualiser les jugements
mais en fait, ce n'est pas suffisant. En effet, éditer les jugements
permettrait de faire de la programmation, mais pas de la
méta-programmation.

Il faut vraiment se donner une syntaxe pour le langage des expressions
du langage de patchs, incluant une syntaxe pour les transformateurs
ainsi que l'ensemble des objets syntaxiques considérés (jugement,
atom, type, etc).

Si on veut définir le "diff", il se passe quelque chose de bizarre
puisque l'on calcule une différence syntaxique entre (deux visualisations
de) deux expressions du langage de patchs qui doit être interprétée
elle-même comme une expression du langage de patchs! Pour ce qui
est de changement syntaxique sur le terme du programme, je suis 
d'accord mais si on change une application de transformateur
en l'application d'un autre transformateur, on n'a pas de langage 
pour exprimer cette transformation! 

Peut-être que je me pose la mauvaise question: lorsque l'on modifie
un noeud correspondant à la modification d'un transformateur, on
est dans le langage calculatoire des patchs (le petit langage
impératif du début). Il se peut quand produisant non pas une 
expression du langage de patchs mais un programme du langage de
patchs, on puisse capturer correctement la différence entre 
deux expressions du langage de patchs. 

Sun Jan 17, 2010  9:38 AM

A propos du related work, il faudra se comparer à Twelf, Delphin et 
Cocinnelle. Pour ce dernier, c'est juste le nom de "semantic patch"
qui est surchargé mais ça n'a pas grand chose à voir, il me semble.

Sun Jan 17, 2010  9:37 AM

Quelque chose d'amusant serait de traiter des commentaires
structurés pouvant contenir du code, à mettre à jour aussi
à travers les patchs. D'une façon générale, on peut même 
interagir avec le programmeur pour que tout commentaire 
qui a été impacté par un patchs puisse être mis-à-jour
intéractivement.

Sun Jan 17, 2010  9:30 AM

En parlant des points de comparaison avec les systèmes de compilation
séparée, il faut noter que notre approche fonctionne uniquement 
dans un cadre open source. Pour traiter l'opacité des dérivations,
ça ne devrait pas être trop dur.

Sun Jan 17, 2010  9:24 AM

A propos des systèmes de modules, je pense qu'il suffirait de définir
un jugement de la forme "env |- decls => env" pour les traiter. Une
question intéressante serait de déterminer différents moyens de
visualiser l'utilisation de modules importés au sein d'un autre
module.

En effet, on peut écrire :
import M
val f x = ...

Pour représenter le méta-programme qui utilise la dérivation de module
M pour construire une nouvelle dérivation de module. Mais on peut
aussi vouloir visualiser dans le buffer, l'ensemble des déclarations
de M (ça évite d'avoir à regarder dans la documentation.).

Comment représenter un foncteur? Peut-être ainsi :

uses Msig
val f x = ...

qui signifie qu'on définit une dérivation de module qui peut-être
jointe à une autre qui remplit la signature Msig.

Comment représenter des contraintes entre les modules? Peut-être ainsi:

uses M1 : M1sig
uses M2 : M2sig
requires M1.t = M2.t

Il faut noter que cette façon de coder les modules les cantonnent à
être des objets de seconde classe. Une question ambitieuse serait de
définir un langage de méta-programmation qui intégrerait dynamiquement
ces constructions. On pourrait ainsi créer des dérivations
dynamiquement et donc charger des modules dynamiquement. Ca reste une
perspective sur du long terme. A mettre dans le Future work.

A propos maintenant d'inférence de type, j'avais des doutes sur la
possibilité de l'intégrer au système mais en fait, il n'y a pas de
raison : on peut très bien définir un jugement de la forme "env |- t
=> t' : tau où t est implicitement typé tandis que t' est
explicitement typé.


Sun Jan 17, 2010  1:15 AM

Un des points de comparaison avec Twelf, c'est tout
simplement que nous n'utilisons la syntaxe d'ordre
supérieure pour représenter les jugements mais
pas pour représenter la syntaxe objet. 

Je ne sais pas trop si c'est très profond comme
comparaison puisqu'on pourrait très bien faire 
de la syntaxe du premier ordre en Twelf ... qui
peut le plus, peut le moins. 

Sun Jan 17, 2010 12:19 AM

Quelques réflexions supplémentaires. 

Le type "dlist", qui sera renommé en "spec", correspond quasi
exactement aux types de LF (i.e. λπ). Plus généralement, l'inductif
"signature" semble correspondre à la définition de théorie LF. 

Le langage de patchs est donc un langage qui correspond à
un sous-ensemble de Delphin[1] (la version constructive et
fonctionnelle de Twelf). Il faudra se comparer à ce langage
et expliquer en quoi la restriction que nous considérons
est digne d'intérêt. D'ailleurs, est-ce qu'on ne pourrait
pas directement (meta)-programmer en Delphin?

La sémantique que j'ai en tête pour le langage de patchs
se décrit comme une transformation d'un "répositoire",
qui est toujours bien formé. Cette transformation
est décrite de façon impérative mais on pourrait très bien
se placer dans une monade et rester fonctionnel. D'ailleurs,
je me demande si une monade de transaction ne serait pas
pertinente pour modéliser la modification concurrente
de répositoire. 

Ensuite, il serait vraiment amusant et intéressant de
voir le langage de patchs et son système de type comme
une entrée possible à lui-même. Je ne sais pas encore
bien expliquer ce qu'on obtient mais à première vue,
c'est un langage de patchs sur des patchs, donc un
moyen de parler de l'historique d'un projet et de
le modifier. 

Enfin, il serait intéressant de voir en quoi le 
langage de patchs se compare aux systèmes de module
et aux systèmes de compilation incrémentale (compilation
séparée). Une question à se poser pourrait être : 
comment construire un ensemble de modules O'Caml
à partir d'un répositoire? Si on se débrouille bien
cette construction pourrait être incrémentale : on
ne génèrerait les modules correspondant uniquement
aux dérivations de typage mis-à-jour. 

Voilà, c'est tout pour aujourd'hui.

[1] http://www.cs.yale.edu/homes/delphin/delphin.htm

Sat Jan 16, 2010  7:21 PM 

Plus je réfléchis aux patchs sémantiques et plus je me dis que le bon
cadre de développement est effectivement Coq. 

Si on prend le point de vue très général qui consiste à voir
les dérivations de typage comme n'importe quel inductif dans
Type (de façon à en avoir une représentation enregistrable 
sur un support physique) et qu'on voit les patchs atomiques
comme des appels à des lemmes écrits en Coq (dont le
type est un transformateur), alors la difficulté de la 
conception d'un système de patchs consiste essentiellement
à la définition dans langage de programmation capturant
les transformations utiles au développement d'un programme
(qui a un aspect un peu plus "méta" que la programmation). 

Voici une proposition simple pour ce langage mais qui
pose déjà des problèmes intéressants. On voit
un programme dans ce langage comme un transformateur
de répositoire/mémoire associant des dérivations à des
emplacement. On a alors l'interprétation suivante 
des trois opérations standards: 

- ref e  : alloue un emplacement frais contenant
  la dérivation de typage ∇.
- ! e    : lit un emplacement.
- x := e : écrit dans un emplacement.

C'est la troisième opération qui est intéressante puisque, pour
préserver le fait que la mémoire peut être interprétée comme une
dérivation de typage correcte, il faut s'assurer que les utilisateurs
de 'x' sont toujours satisfaits. Pour cela, on peut produire des
sous-buts, à la manière des tactiques de Coq. On obtient une sorte de
jeu.  Pour traiter ces sous-buts automatiquement, on peut imaginer
comparer l'ancienne et la nouvelle version de "x" et déduire des
transformations canoniques, lorsqu'elle existe.

Par exemple, si on rajoute un nouveau constructeur dans un ADT, on
peut vouloir rajouter une branche avec un lancement d'exception sur
tous les patterns matchings de ce type. Si on rajoute un nouvel
argument à une fonction, tous les utilisateurs de cette fonction
peuvent être appliqué à une valeur par défaut. Il y a aussi cette
transformation de passage de "map" à "foldmap" (qui doit avoir une
définition catégorique):

let map f = function
| [] -> []
| x :: xs -> (f x) :: map f xs

en 

let fold f accu = function
| [] -> accu, []
| x :: xs ->
  let x', accu = f x accu in
  let accu, xs' = fold f accu xs in
  (accu, x' :: xs')

C'est le passage du type "a -> b" au type "a * c -> b * c"
dont parlait Paul-Andre l'autre fois. L'argument "c" 
suit le flot d'exécution. Quelle est la transformation
similaire qui préserve le tail-call?

On doit pouvoir programmer un interprète pour ce langage en Coq.

La mémoire Δ contiendrait des sommes dépendentes de la forme
Σ T: S. φ (T) où φ est une fonction qui transforme S,
la signature de l'algèbre des objets syntaxiques de 
la théorie (ça peut être un jugement, un environnement,
un terme, peu importe). Une procédure de décision sur
ces objets est du type D ≡ list T -> bool. 

Du coup, les transformateurs ont des types de la forme Θ ≡ list T *
list D * list T, qu'on peut facilement interpréter dans Type. De cette
façon, on élimine le problème d'extensibilité: il suffit de
dynamiquement intégrer un nouveau méta-théorème dans l'environnement
du langage de patchs pour que cela fonctionne. 

Le système de type du langage de patchs obtenu est simple. 

Fri Jan  8, 2010  3:51 PM 

Matthias a présenté son système à base de deux jugements : Δ | t, qui
signifie "je peux construire une dérivation t à partir de mes faits Δ"
et Δ | t → u, "je peux construire une dérivation pour u à partir de
la dérivation de t et de la base de faits Δ". 

Le système est joli mais on a remarqué une certaine redondance : il y
a par exemple une règle d'introduction de la partie gauche d'une
application pour le jugement qui a une flèche et une règle de typage
pour l'application pour le jugement "Δ | t". 

En fait, se focaliser sur une dérivation particulière introduit
une certaine asymétrie : on travaille sur une dérivation particulière
qui n'a rien de plus qu'une autre dérivation de la base Δ. Pourquoi
ne pas travailler directement sur plusieurs dérivations à la fois 
et se permettre d'en déduire plusieurs dérivations? On a donc
adapté le système avec cette idée en introduisant un unique 
jugement : Δ ⊧ Δ' où Δ représente les dérivations qu'on a déjà 
sous la main et Δ' les dérivations que l'on déduit. 

Les règles de typage sont des axiomes de ce système, ainsi que les
métathéorèmes (en particulier, les très utiles "lemmes d'inversion").
La théorie des patchs (paramétrée par le langage) a donc une mission
d'administration des dérivations de typage. Le langage des patchs
décrit des constructions de dérivations (à partir d'autres). A priori,
l'expressivité des constantes est peu limitée, en termes opérationnels
(on peut itérer sur une dérivation pour réécrire les environnements de
jugement). Par contre, l'expressivité du langage de patchs est limitée
puisque c'est un langage dont seule la sémantique statique nous
intéresse vraiment (On pourrait imaginer associer une sémantique
opérationnelle qui réaliserait réellement les constructions
de dérivation de typage de bas-niveau mais si on travail dans Coq,
on a la garantie qu'on ne fait rien de mal.)

Il devrait exister un système de types/une analyse statique
intéressant(e) pour le langage des patchs qui permettrait de donner un
sens à des transformations mais non pas sur des dérivations de typage
sur des patchs eux-mêmes. En effet, les transformations tels que
l'évolution d'un répositoire (qui est un patch) en une nouvelle
version de ce répositoire est un patch! On doit donc, d'une certaine
façon, pouvoir bootstrapper le système. 

Revenons à des choses plus concrètes. Matthias a remarqué que le
jugement "Δ ⊧ Δ'" gagne, certes, en symétrie mais on voit moins bien
ce sur quoi s'applique le patch. En particulier, lorsque les patchs
avec une unique conclusion, on pouvait les décrire à l'aide d'un terme
du langage objet (éventuellement étendu par plongement des
métathéorèmes comme des opérateurs constants). Il semble plus
difficile de jouer avec la syntaxe de cette façon dans le nouveau
système.

Quels sont les prochains objectifs? Je pense qu'il faut avoir ce que
l'on a dit en tête mais se focaliser sur un langage particulier (STLC
par exemple). Je ressens vraiment le besoin d'obtenir un prototype
(soit écrit en Caml ou extrait de Coq) et de pouvoir réellement
(méta-)programmer avec ce système. 

Mon Jan  4, 2010  3:22 PM [semantic patch]

Discussion avec Matthias à propos des patchs sémantiques. Il a
formalisé plusieurs systèmes (en Coq et en Agda) qui énumèrent des
transformations possibles sur des dérivations de typage (préservant la
bonne formation de celles-ci).

Le premier système contient des transformations sur la syntaxe basées
sur les règles dirigées par la syntaxe ainsi que des règles de passage
aux contextes.

Le système final contient des transformations avec mémoire,
c'est-à-dire permettant de nommer des dérivations (et les réutiliser
plus tard). Ce système subsume le précédent.

Ce système semble prometteur : en le codant en Coq et en définissant
une base de hints, Matthias a été capable de vérifier des théorèmes
admissibles automatiquement. Il a pensé rajouter des récurseurs (ou
des opérateurs similaires à ceux des langages de stratégies, comme
Stratego).

Matthias a aussi pu constater une certaine méthodologie pour déduire
automatiquement des règles de transformations à partir des règles
dirigées par la syntaxe. La notion de "méta-théorème" constructif
lui semble aussi de plus en plus naturelle.

Les prochaines étapes :
- vérifier que les bindeurs fonctionnent bien ;
- prendre en compte le contexte et la spécification (i.e. le jugement
 tout entier) ;
- valider un système permettant d'écrire les règles d'affaiblissement
 et de renforcement du contexte.



Fri Dec 18, 2009  3:39 PM

Matthias a posé la question de la vérification de l'application
d'un métathéorème. 

Par exemple, le renommage R[x -> y] s'applique bien sur le 
terme [let x = e1 in e2] mais pas sur le theme [e1].

Est-ce qu'on peut trouver un système de types intéressant pour
vérifier la bonne application de R ?

Yann répond : il suffit d'utiliser Coq mais, c'est un peu facile
comme réponse :). 

Mon Dec 14, 2009  6:29 PM

Une transformation non triviale qui apparait souvent :

let rec f x = 
  ... g y ...
and g y = 
  ... f x ...

devient :

let rec f env x = 
 ... g env y ...
and g env y = 
 ... f env x ...

(ou bien interaction a l'aide d'un '?')
