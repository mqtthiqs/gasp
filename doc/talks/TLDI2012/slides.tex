\documentclass{beamer}

\usepackage{ucs}
\usepackage{amsfonts,amsmath}
\usepackage{stmaryrd}
\usepackage[utf8x]{inputenc}
\usepackage[protrusion=true,expansion=true]{microtype}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{listings}
\usepackage{tikz}

\usepackage{../../macros}

\usetikzlibrary{automata, positioning, shapes.geometric, shapes.misc,
  chains, backgrounds, fit}

\tikzset{
  state/.style={
    rounded rectangle,
    very thick,draw=black!50,
    top color=white, bottom color=black!20,
    minimum size=2em,
    text height=1.5ex,text depth=.25ex
  }
}

\tikzset{
  tribox/.style={
    isosceles triangle,
    isosceles triangle apex angle=40,
  }
}

\setbeamertemplate{footline}[frame number]
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{itemize item}[circle]

\usefonttheme{serif}
\usecolortheme[rgb={0.7,0.2,0.2}]{structure}
\definecolor{greenish}{rgb}{0.20,0.48,0.09} % vert des exemples

\theoremstyle{example}
\newtheorem{remark}[theorem]{\translate{Remark}}
\newtheorem{remarks}[theorem]{\translate{Remarks}}

\lstset{
  language=[Objective]Caml,
  escapechar=\%,
  basicstyle=\sf,
  columns=flexible,
  literate={->}{{$\to$ }}1 {*}{$\times$ }1 {>=}{{$\geq$}}1
  {<>}{{$\neq$}}1 {'a}{{$\alpha$}}1 {'b}{{$\beta$}}1 {'c}{{$\gamma$}}1
}


\date{\small January 28,\\[0.5em] \sf TLDI 2012}

\title{Safe incremental type-checking}

\author[Matthias Puech \& Yann Régis-Gianas] {
  Matthias Puech\inst{1,2} \and Yann Régis-Gianas\inst{2}
}

\institute {
  \inst 1 {Dept. of Computer Science, University of Bologna} \and
  \inst 2 {Univ. Paris Diderot, Sorbonne Paris Cité, PPS, CNRS,  ${\pi}r^2$, INRIA}
}

\begin{document}

\frame\titlepage

\section{Motivation}

\subsection{The problem}

\begin{frame}{\textcolor{gray}{Safe incremental} type-checking}

  \begin{block}{
      \only<1>{Weakly-typed programs need testing}
      \only<2->{Strongly-typed programs need less testing}
    }
    \vspace{1.5em}
    \begin{overlayarea}{\textwidth}{7em}
      \centering
      \only<1>{
        \begin{tikzpicture}[node distance=4em, auto, bend left, >=latex]
          \node[initial, state] (source) {source};
          \node[accepting, state] (exec) [above right=of source] {executable};
          \node[state] (result) [below right=of exec] {result};

          \path[->]
          (source) edge node {compile} (exec)
          (exec) edge node {test} (result)
          (result) edge node {fix} (source) ;
        \end{tikzpicture}
      }

      \only<2->{
        \begin{tikzpicture}[node distance=4em, auto, bend left, >=latex]
          \node[initial, state] (source) {source};
          \node[state] (bool) [above right=of source] {typed source};
          \node[accepting, state] (exec) [below right=of bool] {executable};

          \path[->]
          (source) edge [bend left] node {type-check} (bool)
          (bool) edge [bend left] node {compile} (exec)
          (bool) edge [bend left] node {fix} (source);
        \end{tikzpicture}
      }
    \end{overlayarea}

    \begin{itemize}
    \item<3-> Compilation matters less to the elaboration of programs
      \begin{quote}
        “ If it type-checks, it should work ”
      \end{quote}
    \item<4-> \emph{A fortiori} for proof languages based on types
      (\sysname{Agda}, \sysname{Coq})
    \end{itemize}

  \end{block}

\end{frame}

\begin{frame}{\textcolor{gray}{Safe} incremental
    \textcolor{gray}{type-checking}}


  \begin{onlyenv}<1>
    \begin{block}{Problem}
      Type-checking can be expensive
      \begin{example}
        \begin{itemize}
        \item very large term (whole program)
        \item dependent types (conversion)
        \item type inference (\eg\ \sysname{ML}, unification)
        \end{itemize}
      \end{example}
      But is called repeatedly with \emph{almost} the same input
    \end{block}
  \end{onlyenv}

  \begin{onlyenv}<2>
    \begin{block}{Proposition}
      \emph{Take advantage of the knowledge from previous checks}
      \begin{itemize}
      \item Reuse pieces of derivations (stored in a \emph{repository})
      \item Check only the changed part (the \emph{delta}) of a
        program and its \emph{impact}
      \end{itemize}

        \centering
        \begin{tikzpicture}[node distance=2em, >=latex, hv
          path/.style={to path={-| (\tikztotarget)}}, vh
          path/.style={to path={|- (\tikztotarget)}} ]
          \node (term) {$\delta$}; \node (repo) [below=of
          term]{$\mr$}; \node[state, tribox] (tc) [right=of term]
          {$\mathsf{check}$}; 
          \node (repo2) [right=of tc] {$\mmr$};
          \path[->] (term) edge node {} (tc) (tc) edge node {} (repo2)
          (repo) edge [in=-90, out=0, hv path] node {} (tc) ;
        \end{tikzpicture}
    \end{block}

    \begin{block}{Requirements}
      \begin{itemize}
      \item if $\vdash \delta(\mr) : A$ then $\function{check}{\mr,
          \delta} = \mmr$
      \item $\mathsf{check}$ computes $\mmr$ in less than $O(|\delta(\mr)|)$ \small\qquad (ideally
        $O(|\delta|)$)
      \end{itemize}
    \end{block}
  \end{onlyenv}

\end{frame}

\subsection{Why is it interesting?}

\begin{frame}[fragile]{Expected instances of this problem}
  \begin{block}{Module system}
    We can model \emph{separate module typing} by incrementally
    modifying a term:

    \begin{overlayarea}{\textwidth}{13em}
    \small
    \begin{columns}
      \begin{column}{0.4\textwidth}
        \begin{lstlisting}
module M = struct
  let a : int = 2 + 2
  let b : int -> bool =
    fun x -> x = 4
end
        \end{lstlisting}
\pause
        \begin{lstlisting}
module N = struct
  let c : bool = M.a = 4
  let d : int = M.b 4
end
        \end{lstlisting}
      \end{column}
      \begin{column}{1mm}
        \rule{.1mm}{4cm}
      \end{column}
\pause
      \begin{column}{0.5\textwidth}
        \begin{onlyenv}<3>
        \begin{lstlisting}
let M.a : int = 2 + 2 in
  let M.b : int -> bool =
    fun x -> x = 4 in
    ()
        \end{lstlisting}
        \vspace{2.4em}
        \end{onlyenv}
        \begin{onlyenv}<4->
        \begin{lstlisting}
let M.a : int = 2 + 2 in
  let M.b : int -> bool =
    fun x -> x = 4 in
    let M.c : bool = M.a = 4 in
      let M.d : int = M.b 4 in
        ()
        \end{lstlisting}
        \end{onlyenv}
      \end{column}
    \end{columns}
    \end{overlayarea}
    \begin{visibleenv}<5>
      \begin{remark}
        If definition of \textsf{M.a} changes {\footnotesize (but not its type)}, no need to recheck the rest
      \end{remark}
    \end{visibleenv}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Expected instances of this problem}
  \begin{block}{Interactive toplevel}
    We can model a \emph{\textbf{typing} interactive toplevel} by
    incrementally modifying a term:
    \begin{overlayarea}{\textwidth}{10em}
    \begin{columns}
      \begin{column}{0.47\textwidth}
        \begin{lstlisting}[escapechar=\%]
# let a = 2 + 2 ;;
val a : int% \textcolor{gray}{= 4} %
        \end{lstlisting}
\pause
        \begin{lstlisting}[escapechar=\%]
# let b = fun x -> x = a ;;
val b : int -> bool % \textcolor{gray}{= fun} %
        \end{lstlisting}
      \end{column}
      \begin{column}{.1mm}
        \rule{.1mm}{3cm}
      \end{column}
      \begin{column}{0.44\textwidth}
        \begin{onlyenv}<3>
          \begin{lstlisting}
let a = 2 + 2 in
  a
          \end{lstlisting}
          \vspace{1.2em}
        \end{onlyenv}
        \begin{onlyenv}<4->
          \begin{lstlisting}
let a = 2 + 2 in
  let b = fun x -> x = a in
    b
          \end{lstlisting}
        \end{onlyenv}
      \end{column}
    \end{columns}
    \end{overlayarea}
    \begin{visibleenv}<5>
      \begin{remarks}
        \begin{itemize}
        \item The interaction model of most ITP (\sysname{Coq},
          \sysname{Matita}\ldots)
        \item If definition of \textsf{a} changes, no need to recheck \textsf{b}
        \end{itemize}
      \end{remarks}
    \end{visibleenv}
  \end{block}
\end{frame}

\begin{frame}{Expected instances of this problem}
  \begin{block}{Refactoring tools}
    % spec/semantics-preserving
    We can see \emph{refactoring} as a type-preserving modification
    $\alert f$ of a term, i.e. a \emph{metatheorem}:
    $$ \funname{refactor_{\mathit{\alert f}}}\ :\quad \vdash M : A \quad\text{implies}\quad \vdash \alert f(M) : A $$
  \end{block}
  \begin{examples}
    \begin{itemize}
    \item $\alpha$-conversion (renaming)
    \item $\beta$-contraction/expansion (inlining/factoring)
    \item add argument to function with default value
    \item remove dead code
    \end{itemize}
  \end{examples}
\end{frame}

\begin{frame}{Expected instances of this problem}
  \begin{block}{Typed version control}
    Design a syntax- and type-aware version control system, \ie:

    \begin{itemize}
    \item stores typed AST, not text
    \item well-typing ensured and incrementally checked
    \end{itemize}

    Advantages:
    \begin{itemize}
    \item semantic deltas easier to read\\
      {\small (as opposed to textual \sysname{diff}s)}
    \item $\funname{merge}$ statically well-typed, more precise
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{\textcolor{greenish}{Examples}}
    \begin{center}
      \begin{tabular}{r|l}
      \textcolor{greenish}{initial term} &
      {\large\textbf{let} \textit{f x} = \textit{x} + 1
        \textbf{in} \textit{f} 3 / 2} \\[2em]\pause
      \textcolor{greenish}{easy interleave} &
      {\large\textbf{let} \textit{f x} = \alert{2 *} (\textit{x} + 1) \textbf{in}
        \textit{f} 3 / 2} \\[2em]\pause
      \textcolor{greenish}{env interleave} &
      {\large\textbf{let} \textit{f x} =
        (\alert{\textbf{let} \textit{y} = true \textbf{in}} \textit{x} + 1) \textbf{in}
        \textit{f} 3 / 2} \\[2em]\pause
      \textcolor{greenish}{type change} &
      {\large\textbf{let} \textit{f x} = \textit{x} \alert{$>$} 1 \textbf{in} \only<5>{\alert}{\textit{f} 3 / 2}}
    \end{tabular}
    \end{center}
\end{frame}

\subsection{Why is it hard?}

\begin{frame}[fragile]{Incremental computation}
  \begin{block}{Memoization}\vspace{0.5em}
    \begin{overlayarea}{\textwidth}{.7\textheight}
    \begin{onlyenv}<1-2>
      A \only<2>{\alert{memoizing} }type-checker:
      \begin{overlayarea}{\textwidth}{10em}
        \begin{onlyenv}<1>
          \begin{lstlisting}

let rec check env t =
  match t with
  | ... -> ... None
  | ... -> ... Some a
          \end{lstlisting}
        \end{onlyenv}
        \begin{onlyenv}<2>
          \begin{lstlisting}
let tbl : (env * tm, tp) Hashtbl.t = Hashtbl.create 13
let rec check env t =
  try Hashtbl.find (env,t) tbl with Not_found ->
  match t with
    | ... -> ... None
    | ... -> ... Hashtbl.add tbl (env,t) a; Some a
          \end{lstlisting}
        \end{onlyenv}
      \end{overlayarea}
      \begin{overlayarea}{\textwidth}{3em}
        \begin{beamercolorbox}{white}
          \begin{onlyenv}<1>
            \begin{itemize}
            \item builds the derivation (on the stack)
            \item discards it
            \end{itemize}
          \end{onlyenv}
          \begin{onlyenv}<2>
            \begin{itemize}
            \item builds the derivation (as a global map $\funname{tbl}$)
            \item reuses any subderivation if syntactically equal
            \end{itemize}
          \end{onlyenv}
        \end{beamercolorbox}
      \end{overlayarea}
    \end{onlyenv}

    \begin{onlyenv}<3->
      \begin{enumerate}
      \item<3->[\itplus] lightweight, efficient implementation
      \item<4->[\itplus] random access to all subderivations
      \item<5->[\itminus] no reuse of derivations in compatible
        environments \\
        {\footnotesize what if I want \eg weakening or
          permutation to be taken into account?}
      \item<6->[\itminus] no reuse if refactored program ($\alpha$,
        $\beta$-equivalence,\ldots) \\
        {\footnotesize or complex recognition procedure, enlarging the
          trusted base}
      \item<7->[\itminus] {\large\it no justification for the added code} \\
        {\footnotesize or painful proof of conservativity}
      \end{enumerate}

      \only<8->{
        {\footnotesize Mixes two goals:}

        \begin{itemize}
        \item {\large derivation synthesis} \footnotesize (the typing algorithm)
        \item {\large object reuse} \footnotesize (sharing common subderivation)
        \end{itemize}
      }
    \end{onlyenv}
    \end{overlayarea}
\end{block}
\end{frame}

% mémoization? -> besoin d'un certificat

\begin{frame}{Incremental computation}

  \begin{block}{Bidirectional incremental updates}
    % view the derivation as the document we're editing
    % through a view (the program)
    % --> bijective

    {\centering
    \begin{tikzpicture}[node distance=4em, auto, >=latex]
      \node (D) {$\mathcal D$};
      \node (checkout) [right=of D, state, tribox] {$\funname{get}$};
      \node (M) [right=of checkout] {$M$};
      \node (M') [below=of M] {$M'$};
      \node (commit) [state, tribox, left=of M', shape border
      rotate=180] {$\funname{put}$};
      \node (D') [below=of D] {$\mathcal D'$};

      \path[->]
      (D) edge (checkout)
      (checkout) edge (M)
      (M) edge [color=red, double] node [name=delta] {$\delta$} (M')
      (commit) edge (D')
      ;

      \draw[->]
      (D) |- ++(1,-1) -| (commit)
      ;

      \alt<3>{
        \draw[->] [out=0, in=0, color=red] (delta) edge (commit);
      }{
        \draw[->] (M') edge (commit);
      }

      \begin{pgfonlayer}{background}
        \node [fill=yellow!30,fit=(D) (D'), label=above:Derivations, ellipse] {};
        \node [fill=yellow!30,fit=(M) (M'), label=above:Programs, ellipse] {};
        \node [fill=yellow!30,fit=(checkout) (commit),
        label=above:Lens, ellipse, inner sep=0] {};
      \end{pgfonlayer}

    \end{tikzpicture}
    }
    \begin{overlayarea}{\textwidth}{10em}
      \begin{itemize}
      \item $\function{get}{\mathcal D}$ projects derivation $\mathcal
        D$ to a program $M$
        \begin{onlyenv}<-2>
        \item $\function{put}{\mathcal D, M'}$ checks $M'$ and returns
          its derivation $\mathcal D'$ \pause
          \begin{enumerate}
          \item[\itplus] state-based approach
          \item[\itminus] connection between $\mathcal D$ and $M'$ is
            lost
          \item[\itminus] in $O(|M'|)$, not $O(|\delta|)$
          \end{enumerate}
        \end{onlyenv}
        \begin{onlyenv}<3->
        \item $\function{put}{\mathcal D, \alert\delta}$ checks
          $\alert{\delta}$ against $\alert{\mathcal D}$ and returns
          $\mathcal D'$
          \begin{enumerate}
          \item[\itplus] \alert{change}-based approach
          \item[\itplus] $\delta$ is the connection between $\mathcal
            D$ and $\mathcal D'$
          \item[\itplus] possibly in $O(|\delta|)$
          \item[\itplus] justification for each change ($\mathcal D'$)
          \end{enumerate}
        \end{onlyenv}
      \end{itemize}
    \end{overlayarea}
  \end{block}
\end{frame}

\section{Proposition}

\begin{frame}{What notion of delta?}
  \begin{itemize}
  \item A \textcolor{greenish}{delta} $\delta$ is a term $M$ with
    \emph{metavariables} $\mmeta, \mmmeta$ referring to existing
    sub-derivations:\\[1em]

    $ \delta \gequal \ldots \text{[syntax of $M$]} \ldots \gor
    \mmeta $\\[1em]

  \item A \textcolor{greenish}{repository} $\mr$ is a derivation
    $\mathcal D$ with named, annotated subderivations (\emph{slices})
    with random access:
    \begin{align*}
      \mathcal D^* &\gequal \ldots\text{[syntax of $\mathcal D$]}\ldots
      \gor \mmeta \\
      \mr &\gequal \Delta, \mmeta &\text{where}\quad\Delta : \mmeta\mapsto (\mathcal D^* : J)
    \end{align*}
  \end{itemize}
\end{frame}

\begin{frame}{Safe \textcolor{gray}{incremental type-checking}}


  \begin{block}{A certifying approach}
    \vspace{0.5em}
    {\centering
      \begin{tikzpicture}[
        auto, >=latex,
        hv path/.style={to path={-| (\tikztotarget)}},
        vh path/.style={to path={|- (\tikztotarget)}}
        ]
        \footnotesize
        \node (delta) {$\delta : tm$};
        \node (ti) [state, tribox, right=1em of delta]
        {\textsf{infer}}; 
        \node (deltalf) [right=1em of ti] {$\mathcal D^* : (\vdash \delta : B)$};
        \node (tc) [state, tribox, right=1em of deltalf]
        {\textsf{check}}; 

        \begin{pgfonlayer}{background}
          \node (put) [state, tribox, nearly transparent, rounded corners, fit=(ti.west)
          (tc.apex), align=left] {\Huge\textsf{put}\\[3em]\ };
        \end{pgfonlayer}

        \node(D) [below left=2em and -3.5em of delta] {$\mr : (\vdash M : A)$};
        \node (D') [right=2em of tc] {$\mmr : (\vdash M' : B)$};

        \path[->]

        (delta) edge (ti)
        (ti) edge (deltalf)
        (deltalf) edge (tc)
        (tc) edge (D')
        (D) edge [hv path] (ti) edge [hv path] (tc) ;


      \end{tikzpicture}
      }

    \begin{itemize}
    \item[\textsf{infer}] synthesizes the derivation\\
      {\footnotesize complex, ad-hoc, untrusted, produces a certificate}
    \item[\textsf{check}] checks the certificate\\
      {\footnotesize simple, generic, trusted kernel}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{What justification language?}
  \textbf{LF} can represent uniformly \emph{terms}, \emph{derivation} and
  \emph{metatheorem statements}. Add:
  \begin{itemize}
  \item interpreted functions producing terms (tactics) \\
    {\footnotesize Any OCaml function producing LF terms,
      output verified by \textsf{check}}
    \begin{example}
      \begin{itemize}
      \item[infer :] $\prd M {\const{tm}}
        \{ A : \const{tp}\ |\ \app{\const{of}}\app{\var{M}}{\var{A}} \} =$ \\
        {\small$\quad\mathbf{fun}\ (r : \const{repo}) (e : \const{env}) (m :
          \const{term}) \to \mathbf{match}\ m\ \mathbf{with} \ldots$}
        \\[1em]

      \item[get :] $\prd M {\const{tm}}
        \{A : \const{tp}\ |\ \app{\const{of}}\app{\var{M}}{\var{A}}\}
        \to \const{tm}=$ \\
        {\small$\quad\mathbf{fun}\ (r : \const{repo}) (e : \const{env}) (m :
        \const{term}) \to m$}
        \\[1em]

      \item[]
      \end{itemize}
    \end{example}
    \pause
  \item random access to named, annotated subterms (slices) \\
    {\footnotesize a term is a pair $\Delta, \mmeta$ where $\Delta :
      (\mmeta\mapsto M : A)$}
  \end{itemize}

  \begin{example}
    \vspace{-1.5em}
    \small
    \begin{align*}
      \const{tm} &: \type. &
      \const{tp} &: \type.\\
      \const{app} &: \const{tm}\to \const{tm}\to \const{tm}.  &
      \const{nat} &: \const{tp}.\\
      \const{lam} &: (\const{tm}\to \const{tm})\to \const{tm}. &
      \const{arr} &: \const{tp} \to \const{tp} \to \const{tp}. \\
      \const{of} &: \const{tm} \to \const{tp} \to \type. \\
      \const{of-app} &: \ldots &
      \const{of-lam} &: \ldots
    \end{align*}
    \begin{align*}
      \const{get} &: \prd A {\const{tp}} \prd M {\const{tm}}
      \app{\const{of}}\app{\var M}{\var A} \to \var M \\
      \const{infer} &:  \prd A {\const{tp}} \prd M {\const{tm}}
      \app{\const{of}}\app{\var{M}}{\var{A}} = \\
      & \qquad \mathbf{fun}\ (r : \const{repo}) (e : \const{env}) (a :
      \const{term}) (m : \const{term}) \to \\ & \qquad\quad \mathbf{match}\ m\
      \mathbf{with} \ldots
    \end{align*}
  \end{example}
\end{frame}

\begin{frame}{A logical framework for incremental type-checking}
  \begin{examples}

    \begin{description}
    \item[$\delta_0 = $]
      \const{infer} \const{int} (\textbf{let} \textit{f x} = \textit{x} + 1
      \textbf{in} \textit{f} 3 / 2)
      \pause
      {\footnotesize
        \begin{align*}
          \mathcal D_1 &: (x:\mathrm{int}\vdash x+1 : int) = \ldots \\
          \mathcal D_2 &: (f:\mathrm{int}\to\mathrm{int}\vdash f\ 3\ /\ 2
          : int) = \ldots \\
          \mathcal D_3 &: (\vdash \mathbf{let}\ \mathit{f\ x} = \mathit{x}
          + 1\ \mathbf{in}\ \mathit{f}\ 3\ /\ 2 : int) =
          \mathsf{of\_let}\ \ldots \mathcal D_1\ \mathcal D_2 \\
        \end{align*}}
      \pause
  \item[$\delta_1 = $]
    $
    \mathsf{infer}\ \mathsf{int}\ (\mathbf{let}\ f\ x\ = (\mathsf{get}\ \mathcal D_1) * 2\
    \mathbf{in}\ (\mathsf{get}\ \mathcal D_2))
    $
      % \begin{tabular}{r|l}
      % \textcolor{greenish}{initial term} &
      % \textsf{\large\textbf{let} f x = x + 1
      %   \textbf{in} f 3 / 2} \\[2em]\pause
      % \textcolor{greenish}{easy interleave} &
      % \textsf{\large\textbf{let} f x = \alert{2 *} (x + 1) \textbf{in}
      %   f 3 / 2} \\[2em]\pause
      % \textcolor{greenish}{env interleave} &
      % \textsf{\large\textbf{let} f x =
      %   (\alert{\textbf{let} y = true \textbf{in}} x + 1) \textbf{in}
      %   f 3 / 2} \\[2em]\pause
      % \textcolor{greenish}{type change} &
      % \textsf{\large\textbf{let} f x = x \alert{$>$} 1 \textbf{in} \only<5>{\alert}{f 3 / 2}}
    % \end{tabular}
    \end{description}
  \end{examples}
\end{frame}

\begin{frame}{Conclusion}
  
\end{frame}


\end{document}